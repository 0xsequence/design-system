import{r as Dt,j as L}from"./iframe-BZ0L8c7h.js";import{T as mn}from"./Text-BtXg9hKt.js";import{c as En}from"./index-Dp3B9jqt.js";import{c as vn}from"./classnames-DQzbijWx.js";import"./index-C6VMshcb.js";import"./clsx-B-dksMZM.js";const Bn="0.1.1";function An(){return Bn}class j extends Error{constructor(t,r={}){const n=(()=>{var c;if(r.cause instanceof j){if(r.cause.details)return r.cause.details;if(r.cause.shortMessage)return r.cause.shortMessage}return r.cause&&"details"in r.cause&&typeof r.cause.details=="string"?r.cause.details:(c=r.cause)!=null&&c.message?r.cause.message:r.details})(),i=r.cause instanceof j&&r.cause.docsPath||r.docsPath,o=`https://oxlib.sh${i??""}`,a=[t||"An error occurred.",...r.metaMessages?["",...r.metaMessages]:[],...n||i?["",n?`Details: ${n}`:void 0,i?`See: ${o}`:void 0]:[]].filter(c=>typeof c=="string").join(`
`);super(a,r.cause?{cause:r.cause}:void 0),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"BaseError"}),Object.defineProperty(this,"version",{enumerable:!0,configurable:!0,writable:!0,value:`ox@${An()}`}),this.cause=r.cause,this.details=n,this.docs=o,this.docsPath=i,this.shortMessage=t}walk(t){return Sr(this,t)}}function Sr(e,t){return t!=null&&t(e)?e:e&&typeof e=="object"&&"cause"in e&&e.cause?Sr(e.cause,t):t?null:e}const Se=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Sn(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function de(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function q(e,...t){if(!Sn(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function Ir(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");de(e.outputLen),de(e.blockLen)}function Ue(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Or(e,t){q(e);const r=t.outputLen;if(e.length<r)throw new Error("digestInto() expects output buffer of length at least "+r)}function In(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}function X(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function xe(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function J(e,t){return e<<32-t|e>>>t}function Fe(e,t){return e<<t|e>>>32-t>>>0}const On=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function Cn(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}function Hn(e){for(let t=0;t<e.length;t++)e[t]=Cn(e[t]);return e}const Gt=On?e=>e:Hn,Cr=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",$n=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function Un(e){if(q(e),Cr)return e.toHex();let t="";for(let r=0;r<e.length;r++)t+=$n[e[r]];return t}const te={_0:48,_9:57,A:65,F:70,a:97,f:102};function Zt(e){if(e>=te._0&&e<=te._9)return e-te._0;if(e>=te.A&&e<=te.F)return e-(te.A-10);if(e>=te.a&&e<=te.f)return e-(te.a-10)}function kn(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);if(Cr)return Uint8Array.fromHex(e);const t=e.length,r=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(r);for(let i=0,s=0;i<r;i++,s+=2){const o=Zt(e.charCodeAt(s)),a=Zt(e.charCodeAt(s+1));if(o===void 0||a===void 0){const c=e[s]+e[s+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+s)}n[i]=o*16+a}return n}function zt(e){if(typeof e!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}function nt(e){return typeof e=="string"&&(e=zt(e)),q(e),e}function Yt(e){return typeof e=="string"&&(e=zt(e)),q(e),e}function _e(...e){let t=0;for(let n=0;n<e.length;n++){const i=e[n];q(i),t+=i.length}const r=new Uint8Array(t);for(let n=0,i=0;n<e.length;n++){const s=e[n];r.set(s,i),i+=s.length}return r}function Nn(e,t){if(t!==void 0&&{}.toString.call(t)!=="[object Object]")throw new Error("options should be object or undefined");return Object.assign(e,t)}class Lt{}function it(e){const t=n=>e().update(nt(n)).digest(),r=e();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>e(),t}function zn(e=32){if(Se&&typeof Se.getRandomValues=="function")return Se.getRandomValues(new Uint8Array(e));if(Se&&typeof Se.randomBytes=="function")return Uint8Array.from(Se.randomBytes(e));throw new Error("crypto.getRandomValues must be defined")}function Ln(e,t,r,n){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,r,n);const i=BigInt(32),s=BigInt(4294967295),o=Number(r>>i&s),a=Number(r&s),c=n?4:0,f=n?0:4;e.setUint32(t+c,o,n),e.setUint32(t+f,a,n)}function _n(e,t,r){return e&t^~e&r}function jn(e,t,r){return e&t^e&r^t&r}class _t extends Lt{constructor(t,r,n,i){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=t,this.outputLen=r,this.padOffset=n,this.isLE=i,this.buffer=new Uint8Array(t),this.view=xe(this.buffer)}update(t){Ue(this),t=nt(t),q(t);const{view:r,buffer:n,blockLen:i}=this,s=t.length;for(let o=0;o<s;){const a=Math.min(i-this.pos,s-o);if(a===i){const c=xe(t);for(;i<=s-o;o+=i)this.process(c,o);continue}n.set(t.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===i&&(this.process(r,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Ue(this),Or(t,this),this.finished=!0;const{buffer:r,view:n,blockLen:i,isLE:s}=this;let{pos:o}=this;r[o++]=128,X(this.buffer.subarray(o)),this.padOffset>i-o&&(this.process(n,0),o=0);for(let u=o;u<i;u++)r[u]=0;Ln(n,i-8,BigInt(this.length*8),s),this.process(n,0);const a=xe(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const f=c/4,d=this.get();if(f>d.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<f;u++)a.setUint32(4*u,d[u],s)}digest(){const{buffer:t,outputLen:r}=this;this.digestInto(t);const n=t.slice(0,r);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:r,buffer:n,length:i,finished:s,destroyed:o,pos:a}=this;return t.destroyed=o,t.finished=s,t.length=i,t.pos=a,i%r&&t.buffer.set(n),t}clone(){return this._cloneInto()}}const ae=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),R=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),Pn=Uint8Array.from([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),Hr=Uint8Array.from(new Array(16).fill(0).map((e,t)=>t)),Kn=Hr.map(e=>(9*e+5)%16),$r=(()=>{const r=[[Hr],[Kn]];for(let n=0;n<4;n++)for(let i of r)i.push(i[n].map(s=>Pn[s]));return r})(),Ur=$r[0],kr=$r[1],Nr=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(e=>Uint8Array.from(e)),Tn=Ur.map((e,t)=>e.map(r=>Nr[t][r])),Rn=kr.map((e,t)=>e.map(r=>Nr[t][r])),Fn=Uint32Array.from([0,1518500249,1859775393,2400959708,2840853838]),Mn=Uint32Array.from([1352829926,1548603684,1836072691,2053994217,0]);function Wt(e,t,r,n){return e===0?t^r^n:e===1?t&r|~t&n:e===2?(t|~r)^n:e===3?t&n|r&~n:t^(r|~n)}const Me=new Uint32Array(16);class qn extends _t{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:t,h1:r,h2:n,h3:i,h4:s}=this;return[t,r,n,i,s]}set(t,r,n,i,s){this.h0=t|0,this.h1=r|0,this.h2=n|0,this.h3=i|0,this.h4=s|0}process(t,r){for(let x=0;x<16;x++,r+=4)Me[x]=t.getUint32(r,!0);let n=this.h0|0,i=n,s=this.h1|0,o=s,a=this.h2|0,c=a,f=this.h3|0,d=f,u=this.h4|0,h=u;for(let x=0;x<5;x++){const v=4-x,w=Fn[x],z=Mn[x],N=Ur[x],P=kr[x],y=Tn[x],l=Rn[x];for(let p=0;p<16;p++){const m=Fe(n+Wt(x,s,a,f)+Me[N[p]]+w,y[p])+u|0;n=u,u=f,f=Fe(a,10)|0,a=s,s=m}for(let p=0;p<16;p++){const m=Fe(i+Wt(v,o,c,d)+Me[P[p]]+z,l[p])+h|0;i=h,h=d,d=Fe(c,10)|0,c=o,o=m}}this.set(this.h1+a+d|0,this.h2+f+h|0,this.h3+u+i|0,this.h4+n+o|0,this.h0+s+c|0)}roundClean(){X(Me)}destroy(){this.destroyed=!0,X(this.buffer),this.set(0,0,0,0,0)}}const Vn=it(()=>new qn),qe=BigInt(2**32-1),Xt=BigInt(32);function Dn(e,t=!1){return t?{h:Number(e&qe),l:Number(e>>Xt&qe)}:{h:Number(e>>Xt&qe)|0,l:Number(e&qe)|0}}function zr(e,t=!1){const r=e.length;let n=new Uint32Array(r),i=new Uint32Array(r);for(let s=0;s<r;s++){const{h:o,l:a}=Dn(e[s],t);[n[s],i[s]]=[o,a]}return[n,i]}const Jt=(e,t,r)=>e>>>r,Qt=(e,t,r)=>e<<32-r|t>>>r,Ie=(e,t,r)=>e>>>r|t<<32-r,Oe=(e,t,r)=>e<<32-r|t>>>r,Ve=(e,t,r)=>e<<64-r|t>>>r-32,De=(e,t,r)=>e>>>r-32|t<<64-r,Gn=(e,t,r)=>e<<r|t>>>32-r,Zn=(e,t,r)=>t<<r|e>>>32-r,Yn=(e,t,r)=>t<<r-32|e>>>64-r,Wn=(e,t,r)=>e<<r-32|t>>>64-r;function re(e,t,r,n){const i=(t>>>0)+(n>>>0);return{h:e+r+(i/2**32|0)|0,l:i|0}}const Xn=(e,t,r)=>(e>>>0)+(t>>>0)+(r>>>0),Jn=(e,t,r,n)=>t+r+n+(e/2**32|0)|0,Qn=(e,t,r,n)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0),ei=(e,t,r,n,i)=>t+r+n+i+(e/2**32|0)|0,ti=(e,t,r,n,i)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0)+(i>>>0),ri=(e,t,r,n,i,s)=>t+r+n+i+s+(e/2**32|0)|0,ni=BigInt(0),Le=BigInt(1),ii=BigInt(2),si=BigInt(7),oi=BigInt(256),ci=BigInt(113),Lr=[],_r=[],jr=[];for(let e=0,t=Le,r=1,n=0;e<24;e++){[r,n]=[n,(2*r+3*n)%5],Lr.push(2*(5*n+r)),_r.push((e+1)*(e+2)/2%64);let i=ni;for(let s=0;s<7;s++)t=(t<<Le^(t>>si)*ci)%oi,t&ii&&(i^=Le<<(Le<<BigInt(s))-Le);jr.push(i)}const Pr=zr(jr,!0),ai=Pr[0],fi=Pr[1],er=(e,t,r)=>r>32?Yn(e,t,r):Gn(e,t,r),tr=(e,t,r)=>r>32?Wn(e,t,r):Zn(e,t,r);function ui(e,t=24){const r=new Uint32Array(10);for(let n=24-t;n<24;n++){for(let o=0;o<10;o++)r[o]=e[o]^e[o+10]^e[o+20]^e[o+30]^e[o+40];for(let o=0;o<10;o+=2){const a=(o+8)%10,c=(o+2)%10,f=r[c],d=r[c+1],u=er(f,d,1)^r[a],h=tr(f,d,1)^r[a+1];for(let x=0;x<50;x+=10)e[o+x]^=u,e[o+x+1]^=h}let i=e[2],s=e[3];for(let o=0;o<24;o++){const a=_r[o],c=er(i,s,a),f=tr(i,s,a),d=Lr[o];i=e[d],s=e[d+1],e[d]=c,e[d+1]=f}for(let o=0;o<50;o+=10){for(let a=0;a<10;a++)r[a]=e[o+a];for(let a=0;a<10;a++)e[o+a]^=~r[(a+2)%10]&r[(a+4)%10]}e[0]^=ai[n],e[1]^=fi[n]}X(r)}class jt extends Lt{constructor(t,r,n,i=!1,s=24){if(super(),this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,this.enableXOF=!1,this.blockLen=t,this.suffix=r,this.outputLen=n,this.enableXOF=i,this.rounds=s,de(n),!(0<t&&t<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=In(this.state)}clone(){return this._cloneInto()}keccak(){Gt(this.state32),ui(this.state32,this.rounds),Gt(this.state32),this.posOut=0,this.pos=0}update(t){Ue(this),t=nt(t),q(t);const{blockLen:r,state:n}=this,i=t.length;for(let s=0;s<i;){const o=Math.min(r-this.pos,i-s);for(let a=0;a<o;a++)n[this.pos++]^=t[s++];this.pos===r&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:r,pos:n,blockLen:i}=this;t[n]^=r,(r&128)!==0&&n===i-1&&this.keccak(),t[i-1]^=128,this.keccak()}writeInto(t){Ue(this,!1),q(t),this.finish();const r=this.state,{blockLen:n}=this;for(let i=0,s=t.length;i<s;){this.posOut>=n&&this.keccak();const o=Math.min(n-this.posOut,s-i);t.set(r.subarray(this.posOut,this.posOut+o),i),this.posOut+=o,i+=o}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return de(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(Or(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,X(this.state)}_cloneInto(t){const{blockLen:r,suffix:n,outputLen:i,rounds:s,enableXOF:o}=this;return t||(t=new jt(r,n,i,o,s)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=s,t.suffix=n,t.outputLen=i,t.enableXOF=o,t.destroyed=this.destroyed,t}}const li=(e,t,r)=>it(()=>new jt(t,e,r)),di=li(1,136,256/8),hi=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),fe=new Uint32Array(64);class pi extends _t{constructor(t=32){super(64,t,8,!1),this.A=ae[0]|0,this.B=ae[1]|0,this.C=ae[2]|0,this.D=ae[3]|0,this.E=ae[4]|0,this.F=ae[5]|0,this.G=ae[6]|0,this.H=ae[7]|0}get(){const{A:t,B:r,C:n,D:i,E:s,F:o,G:a,H:c}=this;return[t,r,n,i,s,o,a,c]}set(t,r,n,i,s,o,a,c){this.A=t|0,this.B=r|0,this.C=n|0,this.D=i|0,this.E=s|0,this.F=o|0,this.G=a|0,this.H=c|0}process(t,r){for(let u=0;u<16;u++,r+=4)fe[u]=t.getUint32(r,!1);for(let u=16;u<64;u++){const h=fe[u-15],x=fe[u-2],v=J(h,7)^J(h,18)^h>>>3,w=J(x,17)^J(x,19)^x>>>10;fe[u]=w+fe[u-7]+v+fe[u-16]|0}let{A:n,B:i,C:s,D:o,E:a,F:c,G:f,H:d}=this;for(let u=0;u<64;u++){const h=J(a,6)^J(a,11)^J(a,25),x=d+h+_n(a,c,f)+hi[u]+fe[u]|0,w=(J(n,2)^J(n,13)^J(n,22))+jn(n,i,s)|0;d=f,f=c,c=a,a=o+x|0,o=s,s=i,i=n,n=x+w|0}n=n+this.A|0,i=i+this.B|0,s=s+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,f=f+this.G|0,d=d+this.H|0,this.set(n,i,s,o,a,c,f,d)}roundClean(){X(fe)}destroy(){this.set(0,0,0,0,0,0,0,0),X(this.buffer)}}const Kr=zr(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(e=>BigInt(e))),bi=Kr[0],gi=Kr[1],ue=new Uint32Array(80),le=new Uint32Array(80);class wi extends _t{constructor(t=64){super(128,t,16,!1),this.Ah=R[0]|0,this.Al=R[1]|0,this.Bh=R[2]|0,this.Bl=R[3]|0,this.Ch=R[4]|0,this.Cl=R[5]|0,this.Dh=R[6]|0,this.Dl=R[7]|0,this.Eh=R[8]|0,this.El=R[9]|0,this.Fh=R[10]|0,this.Fl=R[11]|0,this.Gh=R[12]|0,this.Gl=R[13]|0,this.Hh=R[14]|0,this.Hl=R[15]|0}get(){const{Ah:t,Al:r,Bh:n,Bl:i,Ch:s,Cl:o,Dh:a,Dl:c,Eh:f,El:d,Fh:u,Fl:h,Gh:x,Gl:v,Hh:w,Hl:z}=this;return[t,r,n,i,s,o,a,c,f,d,u,h,x,v,w,z]}set(t,r,n,i,s,o,a,c,f,d,u,h,x,v,w,z){this.Ah=t|0,this.Al=r|0,this.Bh=n|0,this.Bl=i|0,this.Ch=s|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=f|0,this.El=d|0,this.Fh=u|0,this.Fl=h|0,this.Gh=x|0,this.Gl=v|0,this.Hh=w|0,this.Hl=z|0}process(t,r){for(let y=0;y<16;y++,r+=4)ue[y]=t.getUint32(r),le[y]=t.getUint32(r+=4);for(let y=16;y<80;y++){const l=ue[y-15]|0,p=le[y-15]|0,m=Ie(l,p,1)^Ie(l,p,8)^Jt(l,p,7),S=Oe(l,p,1)^Oe(l,p,8)^Qt(l,p,7),I=ue[y-2]|0,$=le[y-2]|0,k=Ie(I,$,19)^Ve(I,$,61)^Jt(I,$,6),B=Oe(I,$,19)^De(I,$,61)^Qt(I,$,6),C=Qn(S,B,le[y-7],le[y-16]),A=ei(C,m,k,ue[y-7],ue[y-16]);ue[y]=A|0,le[y]=C|0}let{Ah:n,Al:i,Bh:s,Bl:o,Ch:a,Cl:c,Dh:f,Dl:d,Eh:u,El:h,Fh:x,Fl:v,Gh:w,Gl:z,Hh:N,Hl:P}=this;for(let y=0;y<80;y++){const l=Ie(u,h,14)^Ie(u,h,18)^Ve(u,h,41),p=Oe(u,h,14)^Oe(u,h,18)^De(u,h,41),m=u&x^~u&w,S=h&v^~h&z,I=ti(P,p,S,gi[y],le[y]),$=ri(I,N,l,m,bi[y],ue[y]),k=I|0,B=Ie(n,i,28)^Ve(n,i,34)^Ve(n,i,39),C=Oe(n,i,28)^De(n,i,34)^De(n,i,39),A=n&s^n&a^s&a,K=i&o^i&c^o&c;N=w|0,P=z|0,w=x|0,z=v|0,x=u|0,v=h|0,{h:u,l:h}=re(f|0,d|0,$|0,k|0),f=a|0,d=c|0,a=s|0,c=o|0,s=n|0,o=i|0;const g=Xn(k,C,K);n=Jn(g,$,B,A),i=g|0}({h:n,l:i}=re(this.Ah|0,this.Al|0,n|0,i|0)),{h:s,l:o}=re(this.Bh|0,this.Bl|0,s|0,o|0),{h:a,l:c}=re(this.Ch|0,this.Cl|0,a|0,c|0),{h:f,l:d}=re(this.Dh|0,this.Dl|0,f|0,d|0),{h:u,l:h}=re(this.Eh|0,this.El|0,u|0,h|0),{h:x,l:v}=re(this.Fh|0,this.Fl|0,x|0,v|0),{h:w,l:z}=re(this.Gh|0,this.Gl|0,w|0,z|0),{h:N,l:P}=re(this.Hh|0,this.Hl|0,N|0,P|0),this.set(n,i,s,o,a,c,f,d,u,h,x,v,w,z,N,P)}roundClean(){X(ue,le)}destroy(){X(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const Pt=it(()=>new pi),At=it(()=>new wi);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Kt=BigInt(0),St=BigInt(1);function Te(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Tt(e){if(!Te(e))throw new Error("Uint8Array expected")}function je(e,t){if(typeof t!="boolean")throw new Error(e+" boolean expected, got "+t)}function Ge(e){const t=e.toString(16);return t.length&1?"0"+t:t}function Tr(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?Kt:BigInt("0x"+e)}const Rr=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",xi=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function Pe(e){if(Tt(e),Rr)return e.toHex();let t="";for(let r=0;r<e.length;r++)t+=xi[e[r]];return t}const ne={_0:48,_9:57,A:65,F:70,a:97,f:102};function rr(e){if(e>=ne._0&&e<=ne._9)return e-ne._0;if(e>=ne.A&&e<=ne.F)return e-(ne.A-10);if(e>=ne.a&&e<=ne.f)return e-(ne.a-10)}function et(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);if(Rr)return Uint8Array.fromHex(e);const t=e.length,r=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(r);for(let i=0,s=0;i<r;i++,s+=2){const o=rr(e.charCodeAt(s)),a=rr(e.charCodeAt(s+1));if(o===void 0||a===void 0){const c=e[s]+e[s+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+s)}n[i]=o*16+a}return n}function ye(e){return Tr(Pe(e))}function Fr(e){return Tt(e),Tr(Pe(Uint8Array.from(e).reverse()))}function Re(e,t){return et(e.toString(16).padStart(t*2,"0"))}function Mr(e,t){return Re(e,t).reverse()}function Y(e,t,r){let n;if(typeof t=="string")try{n=et(t)}catch(s){throw new Error(e+" must be hex string or Uint8Array, cause: "+s)}else if(Te(t))n=Uint8Array.from(t);else throw new Error(e+" must be hex string or Uint8Array");const i=n.length;if(typeof r=="number"&&i!==r)throw new Error(e+" of length "+r+" expected, got "+i);return n}function tt(...e){let t=0;for(let n=0;n<e.length;n++){const i=e[n];Tt(i),t+=i.length}const r=new Uint8Array(t);for(let n=0,i=0;n<e.length;n++){const s=e[n];r.set(s,i),i+=s.length}return r}const ft=e=>typeof e=="bigint"&&Kt<=e;function Rt(e,t,r){return ft(e)&&ft(t)&&ft(r)&&t<=e&&e<r}function He(e,t,r,n){if(!Rt(t,r,n))throw new Error("expected valid "+e+": "+r+" <= n < "+n+", got "+t)}function yi(e){let t;for(t=0;e>Kt;e>>=St,t+=1);return t}const st=e=>(St<<BigInt(e))-St,ut=e=>new Uint8Array(e),nr=e=>Uint8Array.from(e);function mi(e,t,r){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof r!="function")throw new Error("hmacFn must be a function");let n=ut(e),i=ut(e),s=0;const o=()=>{n.fill(1),i.fill(0),s=0},a=(...u)=>r(i,n,...u),c=(u=ut(0))=>{i=a(nr([0]),u),n=a(),u.length!==0&&(i=a(nr([1]),u),n=a())},f=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let u=0;const h=[];for(;u<t;){n=a();const x=n.slice();h.push(x),u+=n.length}return tt(...h)};return(u,h)=>{o(),c(u);let x;for(;!(x=h(f()));)c();return o(),x}}const Ei={bigint:e=>typeof e=="bigint",function:e=>typeof e=="function",boolean:e=>typeof e=="boolean",string:e=>typeof e=="string",stringOrUint8Array:e=>typeof e=="string"||Te(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>typeof e=="function"&&Number.isSafeInteger(e.outputLen)};function ot(e,t,r={}){const n=(i,s,o)=>{const a=Ei[s];if(typeof a!="function")throw new Error("invalid validator function");const c=e[i];if(!(o&&c===void 0)&&!a(c,e))throw new Error("param "+String(i)+" is invalid. Expected "+s+", got "+c)};for(const[i,s]of Object.entries(t))n(i,s,!1);for(const[i,s]of Object.entries(r))n(i,s,!0);return e}function ir(e){const t=new WeakMap;return(r,...n)=>{const i=t.get(r);if(i!==void 0)return i;const s=e(r,...n);return t.set(r,s),s}}const vi="#__bigint";function Ft(e,t,r){return JSON.stringify(e,(n,i)=>typeof i=="bigint"?i.toString()+vi:i,r)}function Bi(e,t){if(ar(e)>t)throw new Mi({givenSize:ar(e),maxSize:t})}const ie={zero:48,nine:57,A:65,F:70,a:97,f:102};function sr(e){if(e>=ie.zero&&e<=ie.nine)return e-ie.zero;if(e>=ie.A&&e<=ie.F)return e-(ie.A-10);if(e>=ie.a&&e<=ie.f)return e-(ie.a-10)}function Ai(e,t={}){const{dir:r,size:n=32}=t;if(n===0)return e;if(e.length>n)throw new qi({size:e.length,targetSize:n,type:"Bytes"});const i=new Uint8Array(n);for(let s=0;s<n;s++){const o=r==="right";i[o?s:n-s-1]=e[o?s:e.length-s-1]}return i}function qr(e,t){if(Ee(e)>t)throw new Ni({givenSize:Ee(e),maxSize:t})}function Si(e,t){if(typeof t=="number"&&t>0&&t>Ee(e)-1)throw new Zr({offset:t,position:"start",size:Ee(e)})}function Ii(e,t,r){if(typeof t=="number"&&typeof r=="number"&&Ee(e)!==r-t)throw new Zr({offset:r,position:"end",size:Ee(e)})}function Vr(e,t={}){const{dir:r,size:n=32}=t;if(n===0)return e;const i=e.replace("0x","");if(i.length>n*2)throw new zi({size:Math.ceil(i.length/2),targetSize:n,type:"Hex"});return`0x${i[r==="right"?"padEnd":"padStart"](n*2,"0")}`}const Oi=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function Ci(e,t={}){const{strict:r=!1}=t;if(!e)throw new or(e);if(typeof e!="string")throw new or(e);if(r&&!/^0x[0-9a-fA-F]*$/.test(e))throw new cr(e);if(!e.startsWith("0x"))throw new cr(e)}function Hi(...e){return`0x${e.reduce((t,r)=>t+r.replace("0x",""),"")}`}function Dr(e){return e instanceof Uint8Array?me(e):Array.isArray(e)?me(new Uint8Array(e)):e}function me(e,t={}){let r="";for(let i=0;i<e.length;i++)r+=Oi[e[i]];const n=`0x${r}`;return typeof t.size=="number"?(qr(n,t.size),Gr(n,t.size)):n}function lt(e,t={}){const{signed:r,size:n}=t,i=BigInt(e);let s;n?r?s=(1n<<BigInt(n)*8n-1n)-1n:s=2n**(BigInt(n)*8n)-1n:typeof e=="number"&&(s=BigInt(Number.MAX_SAFE_INTEGER));const o=typeof s=="bigint"&&r?-s-1n:0;if(s&&i>s||i<o){const f=typeof e=="bigint"?"n":"";throw new ki({max:s?`${s}${f}`:void 0,min:`${o}${f}`,signed:r,size:n,value:`${e}${f}`})}const c=`0x${(r&&i<0?(1n<<BigInt(n*8))+BigInt(i):i).toString(16)}`;return n?$i(c,n):c}function $i(e,t){return Vr(e,{dir:"left",size:t})}function Gr(e,t){return Vr(e,{dir:"right",size:t})}function be(e,t,r,n={}){const{strict:i}=n;Si(e,t);const s=`0x${e.replace("0x","").slice((t??0)*2,(r??e.length)*2)}`;return i&&Ii(s,t,r),s}function Ee(e){return Math.ceil((e.length-2)/2)}function Ui(e,t={}){const{strict:r=!1}=t;try{return Ci(e,{strict:r}),!0}catch{return!1}}class ki extends j{constructor({max:t,min:r,signed:n,size:i,value:s}){super(`Number \`${s}\` is not in safe${i?` ${i*8}-bit`:""}${n?" signed":" unsigned"} integer range ${t?`(\`${r}\` to \`${t}\`)`:`(above \`${r}\`)`}`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Hex.IntegerOutOfRangeError"})}}class or extends j{constructor(t){super(`Value \`${typeof t=="object"?Ft(t):t}\` of type \`${typeof t}\` is an invalid hex type.`,{metaMessages:['Hex types must be represented as `"0x${string}"`.']}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Hex.InvalidHexTypeError"})}}class cr extends j{constructor(t){super(`Value \`${t}\` is an invalid hex value.`,{metaMessages:['Hex values must start with `"0x"` and contain only hexadecimal characters (0-9, a-f, A-F).']}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Hex.InvalidHexValueError"})}}let Ni=class extends j{constructor({givenSize:t,maxSize:r}){super(`Size cannot exceed \`${r}\` bytes. Given size: \`${t}\` bytes.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Hex.SizeOverflowError"})}};class Zr extends j{constructor({offset:t,position:r,size:n}){super(`Slice ${r==="start"?"starting":"ending"} at offset \`${t}\` is out-of-bounds (size: \`${n}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Hex.SliceOffsetOutOfBoundsError"})}}let zi=class extends j{constructor({size:t,targetSize:r,type:n}){super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (\`${t}\`) exceeds padding size (\`${r}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Hex.SizeExceedsPaddingSizeError"})}};const Li=new TextEncoder;function _i(e){if(!(e instanceof Uint8Array)){if(!e)throw new Ze(e);if(typeof e!="object")throw new Ze(e);if(!("BYTES_PER_ELEMENT"in e))throw new Ze(e);if(e.BYTES_PER_ELEMENT!==1||e.constructor.name!=="Uint8Array")throw new Ze(e)}}function Yr(e){return e instanceof Uint8Array?e:typeof e=="string"?Pi(e):ji(e)}function ji(e){return e instanceof Uint8Array?e:new Uint8Array(e)}function Pi(e,t={}){const{size:r}=t;let n=e;r&&(qr(e,r),n=Gr(e,r));let i=n.slice(2);i.length%2&&(i=`0${i}`);const s=i.length/2,o=new Uint8Array(s);for(let a=0,c=0;a<s;a++){const f=sr(i.charCodeAt(c++)),d=sr(i.charCodeAt(c++));if(f===void 0||d===void 0)throw new j(`Invalid byte sequence ("${i[c-2]}${i[c-1]}" in "${i}").`);o[a]=f*16+d}return o}function Ki(e,t={}){const{size:r}=t,n=Li.encode(e);return typeof r=="number"?(Bi(n,r),Ti(n,r)):n}function Ti(e,t){return Ai(e,{dir:"right",size:t})}function ar(e){return e.length}function Ri(e,t={}){return me(e,t)}function Fi(e){try{return _i(e),!0}catch{return!1}}class Ze extends j{constructor(t){super(`Value \`${typeof t=="object"?Ft(t):t}\` of type \`${typeof t}\` is an invalid Bytes value.`,{metaMessages:["Bytes values must be of type `Bytes`."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Bytes.InvalidBytesTypeError"})}}class Mi extends j{constructor({givenSize:t,maxSize:r}){super(`Size cannot exceed \`${r}\` bytes. Given size: \`${t}\` bytes.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Bytes.SizeOverflowError"})}}class qi extends j{constructor({size:t,targetSize:r,type:n}){super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (\`${t}\`) exceeds padding size (\`${r}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Bytes.SizeExceedsPaddingSizeError"})}}function Wr(e,t={}){const{as:r=typeof e=="string"?"Hex":"Bytes"}=t,n=di(Yr(e));return r==="Bytes"?n:me(n)}class Vi extends Map{constructor(t){super(),Object.defineProperty(this,"maxSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxSize=t}get(t){const r=super.get(t);return super.has(t)&&r!==void 0&&(this.delete(t),super.set(t,r)),r}set(t,r){if(super.set(t,r),this.maxSize&&this.size>this.maxSize){const n=this.keys().next().value;n&&this.delete(n)}return this}}const Di={checksum:new Vi(8192)},dt=Di.checksum;function Xr(e,t={}){const{compressed:r}=t,{prefix:n,x:i,y:s}=e;if(r===!1||typeof i=="bigint"&&typeof s=="bigint"){if(n!==4)throw new fr({prefix:n,cause:new Ji});return}if(r===!0||typeof i=="bigint"&&typeof s>"u"){if(n!==3&&n!==2)throw new fr({prefix:n,cause:new Xi});return}throw new Wi({publicKey:e})}function Gi(e){const t=(()=>{if(Ui(e))return Jr(e);if(Fi(e))return Zi(e);const{prefix:r,x:n,y:i}=e;return typeof n=="bigint"&&typeof i=="bigint"?{prefix:r??4,x:n,y:i}:{prefix:r,x:n}})();return Xr(t),t}function Zi(e){return Jr(me(e))}function Jr(e){if(e.length!==132&&e.length!==130&&e.length!==68)throw new Qi({publicKey:e});if(e.length===130){const n=BigInt(be(e,0,32)),i=BigInt(be(e,32,64));return{prefix:4,x:n,y:i}}if(e.length===132){const n=Number(be(e,0,1)),i=BigInt(be(e,1,33)),s=BigInt(be(e,33,65));return{prefix:n,x:i,y:s}}const t=Number(be(e,0,1)),r=BigInt(be(e,1,33));return{prefix:t,x:r}}function Yi(e,t={}){Xr(e);const{prefix:r,x:n,y:i}=e,{includePrefix:s=!0}=t;return Hi(s?lt(r,{size:1}):"0x",lt(n,{size:32}),typeof i=="bigint"?lt(i,{size:32}):"0x")}class Wi extends j{constructor({publicKey:t}){super(`Value \`${Ft(t)}\` is not a valid public key.`,{metaMessages:["Public key must contain:","- an `x` and `prefix` value (compressed)","- an `x`, `y`, and `prefix` value (uncompressed)"]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"PublicKey.InvalidError"})}}class fr extends j{constructor({prefix:t,cause:r}){super(`Prefix "${t}" is invalid.`,{cause:r}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"PublicKey.InvalidPrefixError"})}}class Xi extends j{constructor(){super("Prefix must be 2 or 3 for compressed public keys."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"PublicKey.InvalidCompressedPrefixError"})}}class Ji extends j{constructor(){super("Prefix must be 4 for uncompressed public keys."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"PublicKey.InvalidUncompressedPrefixError"})}}class Qi extends j{constructor({publicKey:t}){super(`Value \`${t}\` is an invalid public key size.`,{metaMessages:["Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).",`Received ${Ee(Dr(t))} bytes.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"PublicKey.InvalidSerializedSizeError"})}}const es=/^0x[a-fA-F0-9]{40}$/;function Qr(e,t={}){const{strict:r=!0}=t;if(!es.test(e))throw new ur({address:e,cause:new ns});if(r){if(e.toLowerCase()===e)return;if(Mt(e)!==e)throw new ur({address:e,cause:new is})}}function Mt(e){if(dt.has(e))return dt.get(e);Qr(e,{strict:!1});const t=e.substring(2).toLowerCase(),r=Wr(Ki(t),{as:"Bytes"}),n=t.split("");for(let s=0;s<40;s+=2)r[s>>1]>>4>=8&&n[s]&&(n[s]=n[s].toUpperCase()),(r[s>>1]&15)>=8&&n[s+1]&&(n[s+1]=n[s+1].toUpperCase());const i=`0x${n.join("")}`;return dt.set(e,i),i}function ts(e,t={}){const{checksum:r=!1}=t;return Qr(e),r?Mt(e):e}function rs(e,t={}){const r=Wr(`0x${Yi(e).slice(4)}`).substring(26);return ts(`0x${r}`,t)}class ur extends j{constructor({address:t,cause:r}){super(`Address "${t}" is invalid.`,{cause:r}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Address.InvalidAddressError"})}}class ns extends j{constructor(){super("Address is not a 20 byte (40 hexadecimal character) value."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Address.InvalidInputError"})}}class is extends j{constructor(){super("Address does not match its checksum counterpart."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Address.InvalidChecksumError"})}}class en extends Lt{constructor(t,r){super(),this.finished=!1,this.destroyed=!1,Ir(t);const n=nt(r);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,s=new Uint8Array(i);s.set(n.length>i?t.create().update(n).digest():n);for(let o=0;o<s.length;o++)s[o]^=54;this.iHash.update(s),this.oHash=t.create();for(let o=0;o<s.length;o++)s[o]^=106;this.oHash.update(s),X(s)}update(t){return Ue(this),this.iHash.update(t),this}digestInto(t){Ue(this),q(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:r,iHash:n,finished:i,destroyed:s,blockLen:o,outputLen:a}=this;return t=t,t.finished=i,t.destroyed=s,t.blockLen=o,t.outputLen=a,t.oHash=r._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Ke=(e,t,r)=>new en(e,t).update(r).digest();Ke.create=(e,t)=>new en(e,t);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const G=BigInt(0),V=BigInt(1),we=BigInt(2),ss=BigInt(3),tn=BigInt(4),rn=BigInt(5),nn=BigInt(8);function M(e,t){const r=e%t;return r>=G?r:t+r}function Z(e,t,r){let n=e;for(;t-- >G;)n*=n,n%=r;return n}function It(e,t){if(e===G)throw new Error("invert: expected non-zero number");if(t<=G)throw new Error("invert: expected positive modulus, got "+t);let r=M(e,t),n=t,i=G,s=V;for(;r!==G;){const a=n/r,c=n%r,f=i-s*a;n=r,r=c,i=s,s=f}if(n!==V)throw new Error("invert: does not exist");return M(i,t)}function sn(e,t){const r=(e.ORDER+V)/tn,n=e.pow(t,r);if(!e.eql(e.sqr(n),t))throw new Error("Cannot find square root");return n}function os(e,t){const r=(e.ORDER-rn)/nn,n=e.mul(t,we),i=e.pow(n,r),s=e.mul(t,i),o=e.mul(e.mul(s,we),i),a=e.mul(s,e.sub(o,e.ONE));if(!e.eql(e.sqr(a),t))throw new Error("Cannot find square root");return a}function cs(e){if(e<BigInt(3))throw new Error("sqrt is not defined for small field");let t=e-V,r=0;for(;t%we===G;)t/=we,r++;let n=we;const i=qt(e);for(;lr(i,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(r===1)return sn;let s=i.pow(n,t);const o=(t+V)/we;return function(c,f){if(c.is0(f))return f;if(lr(c,f)!==1)throw new Error("Cannot find square root");let d=r,u=c.mul(c.ONE,s),h=c.pow(f,t),x=c.pow(f,o);for(;!c.eql(h,c.ONE);){if(c.is0(h))return c.ZERO;let v=1,w=c.sqr(h);for(;!c.eql(w,c.ONE);)if(v++,w=c.sqr(w),v===d)throw new Error("Cannot find square root");const z=V<<BigInt(d-v-1),N=c.pow(u,z);d=v,u=c.sqr(N),h=c.mul(h,u),x=c.mul(x,N)}return x}}function as(e){return e%tn===ss?sn:e%nn===rn?os:cs(e)}const fs=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function us(e){const t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},r=fs.reduce((n,i)=>(n[i]="function",n),t);return ot(e,r)}function ls(e,t,r){if(r<G)throw new Error("invalid exponent, negatives unsupported");if(r===G)return e.ONE;if(r===V)return t;let n=e.ONE,i=t;for(;r>G;)r&V&&(n=e.mul(n,i)),i=e.sqr(i),r>>=V;return n}function on(e,t,r=!1){const n=new Array(t.length).fill(r?e.ZERO:void 0),i=t.reduce((o,a,c)=>e.is0(a)?o:(n[c]=o,e.mul(o,a)),e.ONE),s=e.inv(i);return t.reduceRight((o,a,c)=>e.is0(a)?o:(n[c]=e.mul(o,n[c]),e.mul(o,a)),s),n}function lr(e,t){const r=(e.ORDER-V)/we,n=e.pow(t,r),i=e.eql(n,e.ONE),s=e.eql(n,e.ZERO),o=e.eql(n,e.neg(e.ONE));if(!i&&!s&&!o)throw new Error("invalid Legendre symbol result");return i?1:s?0:-1}function cn(e,t){t!==void 0&&de(t);const r=t!==void 0?t:e.toString(2).length,n=Math.ceil(r/8);return{nBitLength:r,nByteLength:n}}function qt(e,t,r=!1,n={}){if(e<=G)throw new Error("invalid field: expected ORDER > 0, got "+e);const{nBitLength:i,nByteLength:s}=cn(e,t);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let o;const a=Object.freeze({ORDER:e,isLE:r,BITS:i,BYTES:s,MASK:st(i),ZERO:G,ONE:V,create:c=>M(c,e),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return G<=c&&c<e},is0:c=>c===G,isOdd:c=>(c&V)===V,neg:c=>M(-c,e),eql:(c,f)=>c===f,sqr:c=>M(c*c,e),add:(c,f)=>M(c+f,e),sub:(c,f)=>M(c-f,e),mul:(c,f)=>M(c*f,e),pow:(c,f)=>ls(a,c,f),div:(c,f)=>M(c*It(f,e),e),sqrN:c=>c*c,addN:(c,f)=>c+f,subN:(c,f)=>c-f,mulN:(c,f)=>c*f,inv:c=>It(c,e),sqrt:n.sqrt||(c=>(o||(o=as(e)),o(a,c))),toBytes:c=>r?Mr(c,s):Re(c,s),fromBytes:c=>{if(c.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+c.length);return r?Fr(c):ye(c)},invertBatch:c=>on(a,c),cmov:(c,f,d)=>d?f:c});return Object.freeze(a)}function an(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function fn(e){const t=an(e);return t+Math.ceil(t/2)}function ds(e,t,r=!1){const n=e.length,i=an(t),s=fn(t);if(n<16||n<s||n>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+n);const o=r?Fr(e):ye(e),a=M(o,t-V)+V;return r?Mr(a,i):Re(a,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const dr=BigInt(0),Ot=BigInt(1);function ht(e,t){const r=t.negate();return e?r:t}function un(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+e)}function pt(e,t){un(e,t);const r=Math.ceil(t/e)+1,n=2**(e-1),i=2**e,s=st(e),o=BigInt(e);return{windows:r,windowSize:n,mask:s,maxNumber:i,shiftBy:o}}function hr(e,t,r){const{windowSize:n,mask:i,maxNumber:s,shiftBy:o}=r;let a=Number(e&i),c=e>>o;a>n&&(a-=s,c+=Ot);const f=t*n,d=f+Math.abs(a)-1,u=a===0,h=a<0,x=t%2!==0;return{nextN:c,offset:d,isZero:u,isNeg:h,isNegF:x,offsetF:f}}function hs(e,t){if(!Array.isArray(e))throw new Error("array expected");e.forEach((r,n)=>{if(!(r instanceof t))throw new Error("invalid point at index "+n)})}function ps(e,t){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((r,n)=>{if(!t.isValid(r))throw new Error("invalid scalar at index "+n)})}const bt=new WeakMap,ln=new WeakMap;function gt(e){return ln.get(e)||1}function bs(e,t){return{constTimeNegate:ht,hasPrecomputes(r){return gt(r)!==1},unsafeLadder(r,n,i=e.ZERO){let s=r;for(;n>dr;)n&Ot&&(i=i.add(s)),s=s.double(),n>>=Ot;return i},precomputeWindow(r,n){const{windows:i,windowSize:s}=pt(n,t),o=[];let a=r,c=a;for(let f=0;f<i;f++){c=a,o.push(c);for(let d=1;d<s;d++)c=c.add(a),o.push(c);a=c.double()}return o},wNAF(r,n,i){let s=e.ZERO,o=e.BASE;const a=pt(r,t);for(let c=0;c<a.windows;c++){const{nextN:f,offset:d,isZero:u,isNeg:h,isNegF:x,offsetF:v}=hr(i,c,a);i=f,u?o=o.add(ht(x,n[v])):s=s.add(ht(h,n[d]))}return{p:s,f:o}},wNAFUnsafe(r,n,i,s=e.ZERO){const o=pt(r,t);for(let a=0;a<o.windows&&i!==dr;a++){const{nextN:c,offset:f,isZero:d,isNeg:u}=hr(i,a,o);if(i=c,!d){const h=n[f];s=s.add(u?h.negate():h)}}return s},getPrecomputes(r,n,i){let s=bt.get(n);return s||(s=this.precomputeWindow(n,r),r!==1&&bt.set(n,i(s))),s},wNAFCached(r,n,i){const s=gt(r);return this.wNAF(s,this.getPrecomputes(s,r,i),n)},wNAFCachedUnsafe(r,n,i,s){const o=gt(r);return o===1?this.unsafeLadder(r,n,s):this.wNAFUnsafe(o,this.getPrecomputes(o,r,i),n,s)},setWindowSize(r,n){un(n,t),ln.set(r,n),bt.delete(r)}}}function gs(e,t,r,n){hs(r,e),ps(n,t);const i=r.length,s=n.length;if(i!==s)throw new Error("arrays of points and scalars must have equal length");const o=e.ZERO,a=yi(BigInt(i));let c=1;a>12?c=a-3:a>4?c=a-2:a>0&&(c=2);const f=st(c),d=new Array(Number(f)+1).fill(o),u=Math.floor((t.BITS-1)/c)*c;let h=o;for(let x=u;x>=0;x-=c){d.fill(o);for(let w=0;w<s;w++){const z=n[w],N=Number(z>>BigInt(x)&f);d[N]=d[N].add(r[w])}let v=o;for(let w=d.length-1,z=o;w>0;w--)z=z.add(d[w]),v=v.add(z);if(h=h.add(v),x!==0)for(let w=0;w<c;w++)h=h.double()}return h}function dn(e){return us(e.Fp),ot(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...cn(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function pr(e){e.lowS!==void 0&&je("lowS",e.lowS),e.prehash!==void 0&&je("prehash",e.prehash)}function ws(e){const t=dn(e);ot(t,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:r,Fp:n,a:i}=t;if(r){if(!n.eql(i,n.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if(typeof r!="object"||typeof r.beta!="bigint"||typeof r.splitScalar!="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...t})}class xs extends Error{constructor(t=""){super(t)}}const se={Err:xs,_tlv:{encode:(e,t)=>{const{Err:r}=se;if(e<0||e>256)throw new r("tlv.encode: wrong tag");if(t.length&1)throw new r("tlv.encode: unpadded data");const n=t.length/2,i=Ge(n);if(i.length/2&128)throw new r("tlv.encode: long form length too big");const s=n>127?Ge(i.length/2|128):"";return Ge(e)+s+i+t},decode(e,t){const{Err:r}=se;let n=0;if(e<0||e>256)throw new r("tlv.encode: wrong tag");if(t.length<2||t[n++]!==e)throw new r("tlv.decode: wrong tlv");const i=t[n++],s=!!(i&128);let o=0;if(!s)o=i;else{const c=i&127;if(!c)throw new r("tlv.decode(long): indefinite length not supported");if(c>4)throw new r("tlv.decode(long): byte length is too big");const f=t.subarray(n,n+c);if(f.length!==c)throw new r("tlv.decode: length bytes not complete");if(f[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(const d of f)o=o<<8|d;if(n+=c,o<128)throw new r("tlv.decode(long): not minimal encoding")}const a=t.subarray(n,n+o);if(a.length!==o)throw new r("tlv.decode: wrong value length");return{v:a,l:t.subarray(n+o)}}},_int:{encode(e){const{Err:t}=se;if(e<oe)throw new t("integer: negative integers are not allowed");let r=Ge(e);if(Number.parseInt(r[0],16)&8&&(r="00"+r),r.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return r},decode(e){const{Err:t}=se;if(e[0]&128)throw new t("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return ye(e)}},toSig(e){const{Err:t,_int:r,_tlv:n}=se,i=Y("signature",e),{v:s,l:o}=n.decode(48,i);if(o.length)throw new t("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,s),{v:f,l:d}=n.decode(2,c);if(d.length)throw new t("invalid signature: left bytes after parsing");return{r:r.decode(a),s:r.decode(f)}},hexFromSig(e){const{_tlv:t,_int:r}=se,n=t.encode(2,r.encode(e.r)),i=t.encode(2,r.encode(e.s)),s=n+i;return t.encode(48,s)}};function wt(e,t){return Pe(Re(e,t))}const oe=BigInt(0),T=BigInt(1);BigInt(2);const xt=BigInt(3),ys=BigInt(4);function ms(e){const t=ws(e),{Fp:r}=t,n=qt(t.n,t.nBitLength),i=t.toBytes||((y,l,p)=>{const m=l.toAffine();return tt(Uint8Array.from([4]),r.toBytes(m.x),r.toBytes(m.y))}),s=t.fromBytes||(y=>{const l=y.subarray(1),p=r.fromBytes(l.subarray(0,r.BYTES)),m=r.fromBytes(l.subarray(r.BYTES,2*r.BYTES));return{x:p,y:m}});function o(y){const{a:l,b:p}=t,m=r.sqr(y),S=r.mul(m,y);return r.add(r.add(S,r.mul(y,l)),p)}function a(y,l){const p=r.sqr(l),m=o(y);return r.eql(p,m)}if(!a(t.Gx,t.Gy))throw new Error("bad curve params: generator point");const c=r.mul(r.pow(t.a,xt),ys),f=r.mul(r.sqr(t.b),BigInt(27));if(r.is0(r.add(c,f)))throw new Error("bad curve params: a or b");function d(y){return Rt(y,T,t.n)}function u(y){const{allowedPrivateKeyLengths:l,nByteLength:p,wrapPrivateKey:m,n:S}=t;if(l&&typeof y!="bigint"){if(Te(y)&&(y=Pe(y)),typeof y!="string"||!l.includes(y.length))throw new Error("invalid private key");y=y.padStart(p*2,"0")}let I;try{I=typeof y=="bigint"?y:ye(Y("private key",y,p))}catch{throw new Error("invalid private key, expected hex or "+p+" bytes, got "+typeof y)}return m&&(I=M(I,S)),He("private key",I,T,S),I}function h(y){if(!(y instanceof w))throw new Error("ProjectivePoint expected")}const x=ir((y,l)=>{const{px:p,py:m,pz:S}=y;if(r.eql(S,r.ONE))return{x:p,y:m};const I=y.is0();l==null&&(l=I?r.ONE:r.inv(S));const $=r.mul(p,l),k=r.mul(m,l),B=r.mul(S,l);if(I)return{x:r.ZERO,y:r.ZERO};if(!r.eql(B,r.ONE))throw new Error("invZ was invalid");return{x:$,y:k}}),v=ir(y=>{if(y.is0()){if(t.allowInfinityPoint&&!r.is0(y.py))return;throw new Error("bad point: ZERO")}const{x:l,y:p}=y.toAffine();if(!r.isValid(l)||!r.isValid(p))throw new Error("bad point: x or y not FE");if(!a(l,p))throw new Error("bad point: equation left != right");if(!y.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class w{constructor(l,p,m){if(l==null||!r.isValid(l))throw new Error("x required");if(p==null||!r.isValid(p)||r.is0(p))throw new Error("y required");if(m==null||!r.isValid(m))throw new Error("z required");this.px=l,this.py=p,this.pz=m,Object.freeze(this)}static fromAffine(l){const{x:p,y:m}=l||{};if(!l||!r.isValid(p)||!r.isValid(m))throw new Error("invalid affine point");if(l instanceof w)throw new Error("projective point not allowed");const S=I=>r.eql(I,r.ZERO);return S(p)&&S(m)?w.ZERO:new w(p,m,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(l){const p=on(r,l.map(m=>m.pz));return l.map((m,S)=>m.toAffine(p[S])).map(w.fromAffine)}static fromHex(l){const p=w.fromAffine(s(Y("pointHex",l)));return p.assertValidity(),p}static fromPrivateKey(l){return w.BASE.multiply(u(l))}static msm(l,p){return gs(w,n,l,p)}_setWindowSize(l){P.setWindowSize(this,l)}assertValidity(){v(this)}hasEvenY(){const{y:l}=this.toAffine();if(r.isOdd)return!r.isOdd(l);throw new Error("Field doesn't support isOdd")}equals(l){h(l);const{px:p,py:m,pz:S}=this,{px:I,py:$,pz:k}=l,B=r.eql(r.mul(p,k),r.mul(I,S)),C=r.eql(r.mul(m,k),r.mul($,S));return B&&C}negate(){return new w(this.px,r.neg(this.py),this.pz)}double(){const{a:l,b:p}=t,m=r.mul(p,xt),{px:S,py:I,pz:$}=this;let k=r.ZERO,B=r.ZERO,C=r.ZERO,A=r.mul(S,S),K=r.mul(I,I),g=r.mul($,$),b=r.mul(S,I);return b=r.add(b,b),C=r.mul(S,$),C=r.add(C,C),k=r.mul(l,C),B=r.mul(m,g),B=r.add(k,B),k=r.sub(K,B),B=r.add(K,B),B=r.mul(k,B),k=r.mul(b,k),C=r.mul(m,C),g=r.mul(l,g),b=r.sub(A,g),b=r.mul(l,b),b=r.add(b,C),C=r.add(A,A),A=r.add(C,A),A=r.add(A,g),A=r.mul(A,b),B=r.add(B,A),g=r.mul(I,$),g=r.add(g,g),A=r.mul(g,b),k=r.sub(k,A),C=r.mul(g,K),C=r.add(C,C),C=r.add(C,C),new w(k,B,C)}add(l){h(l);const{px:p,py:m,pz:S}=this,{px:I,py:$,pz:k}=l;let B=r.ZERO,C=r.ZERO,A=r.ZERO;const K=t.a,g=r.mul(t.b,xt);let b=r.mul(p,I),E=r.mul(m,$),U=r.mul(S,k),O=r.add(p,m),H=r.add(I,$);O=r.mul(O,H),H=r.add(b,E),O=r.sub(O,H),H=r.add(p,S);let _=r.add(I,k);return H=r.mul(H,_),_=r.add(b,U),H=r.sub(H,_),_=r.add(m,S),B=r.add($,k),_=r.mul(_,B),B=r.add(E,U),_=r.sub(_,B),A=r.mul(K,H),B=r.mul(g,U),A=r.add(B,A),B=r.sub(E,A),A=r.add(E,A),C=r.mul(B,A),E=r.add(b,b),E=r.add(E,b),U=r.mul(K,U),H=r.mul(g,H),E=r.add(E,U),U=r.sub(b,U),U=r.mul(K,U),H=r.add(H,U),b=r.mul(E,H),C=r.add(C,b),b=r.mul(_,H),B=r.mul(O,B),B=r.sub(B,b),b=r.mul(O,E),A=r.mul(_,A),A=r.add(A,b),new w(B,C,A)}subtract(l){return this.add(l.negate())}is0(){return this.equals(w.ZERO)}wNAF(l){return P.wNAFCached(this,l,w.normalizeZ)}multiplyUnsafe(l){const{endo:p,n:m}=t;He("scalar",l,oe,m);const S=w.ZERO;if(l===oe)return S;if(this.is0()||l===T)return this;if(!p||P.hasPrecomputes(this))return P.wNAFCachedUnsafe(this,l,w.normalizeZ);let{k1neg:I,k1:$,k2neg:k,k2:B}=p.splitScalar(l),C=S,A=S,K=this;for(;$>oe||B>oe;)$&T&&(C=C.add(K)),B&T&&(A=A.add(K)),K=K.double(),$>>=T,B>>=T;return I&&(C=C.negate()),k&&(A=A.negate()),A=new w(r.mul(A.px,p.beta),A.py,A.pz),C.add(A)}multiply(l){const{endo:p,n:m}=t;He("scalar",l,T,m);let S,I;if(p){const{k1neg:$,k1:k,k2neg:B,k2:C}=p.splitScalar(l);let{p:A,f:K}=this.wNAF(k),{p:g,f:b}=this.wNAF(C);A=P.constTimeNegate($,A),g=P.constTimeNegate(B,g),g=new w(r.mul(g.px,p.beta),g.py,g.pz),S=A.add(g),I=K.add(b)}else{const{p:$,f:k}=this.wNAF(l);S=$,I=k}return w.normalizeZ([S,I])[0]}multiplyAndAddUnsafe(l,p,m){const S=w.BASE,I=(k,B)=>B===oe||B===T||!k.equals(S)?k.multiplyUnsafe(B):k.multiply(B),$=I(this,p).add(I(l,m));return $.is0()?void 0:$}toAffine(l){return x(this,l)}isTorsionFree(){const{h:l,isTorsionFree:p}=t;if(l===T)return!0;if(p)return p(w,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:l,clearCofactor:p}=t;return l===T?this:p?p(w,this):this.multiplyUnsafe(t.h)}toRawBytes(l=!0){return je("isCompressed",l),this.assertValidity(),i(w,this,l)}toHex(l=!0){return je("isCompressed",l),Pe(this.toRawBytes(l))}}w.BASE=new w(t.Gx,t.Gy,r.ONE),w.ZERO=new w(r.ZERO,r.ONE,r.ZERO);const{endo:z,nBitLength:N}=t,P=bs(w,z?Math.ceil(N/2):N);return{CURVE:t,ProjectivePoint:w,normPrivateKeyToScalar:u,weierstrassEquation:o,isWithinCurveOrder:d}}function Es(e){const t=dn(e);return ot(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function vs(e){const t=Es(e),{Fp:r,n,nByteLength:i,nBitLength:s}=t,o=r.BYTES+1,a=2*r.BYTES+1;function c(g){return M(g,n)}function f(g){return It(g,n)}const{ProjectivePoint:d,normPrivateKeyToScalar:u,weierstrassEquation:h,isWithinCurveOrder:x}=ms({...t,toBytes(g,b,E){const U=b.toAffine(),O=r.toBytes(U.x),H=tt;return je("isCompressed",E),E?H(Uint8Array.from([b.hasEvenY()?2:3]),O):H(Uint8Array.from([4]),O,r.toBytes(U.y))},fromBytes(g){const b=g.length,E=g[0],U=g.subarray(1);if(b===o&&(E===2||E===3)){const O=ye(U);if(!Rt(O,T,r.ORDER))throw new Error("Point is not on curve");const H=h(O);let _;try{_=r.sqrt(H)}catch(W){const D=W instanceof Error?": "+W.message:"";throw new Error("Point is not on curve"+D)}const F=(_&T)===T;return(E&1)===1!==F&&(_=r.neg(_)),{x:O,y:_}}else if(b===a&&E===4){const O=r.fromBytes(U.subarray(0,r.BYTES)),H=r.fromBytes(U.subarray(r.BYTES,2*r.BYTES));return{x:O,y:H}}else{const O=o,H=a;throw new Error("invalid Point, expected length of "+O+", or uncompressed "+H+", got "+b)}}});function v(g){const b=n>>T;return g>b}function w(g){return v(g)?c(-g):g}const z=(g,b,E)=>ye(g.slice(b,E));class N{constructor(b,E,U){He("r",b,T,n),He("s",E,T,n),this.r=b,this.s=E,U!=null&&(this.recovery=U),Object.freeze(this)}static fromCompact(b){const E=i;return b=Y("compactSignature",b,E*2),new N(z(b,0,E),z(b,E,2*E))}static fromDER(b){const{r:E,s:U}=se.toSig(Y("DER",b));return new N(E,U)}assertValidity(){}addRecoveryBit(b){return new N(this.r,this.s,b)}recoverPublicKey(b){const{r:E,s:U,recovery:O}=this,H=S(Y("msgHash",b));if(O==null||![0,1,2,3].includes(O))throw new Error("recovery id invalid");const _=O===2||O===3?E+t.n:E;if(_>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const F=(O&1)===0?"02":"03",ee=d.fromHex(F+wt(_,r.BYTES)),W=f(_),D=c(-H*W),ve=c(U*W),ce=d.BASE.multiplyAndAddUnsafe(ee,D,ve);if(!ce)throw new Error("point at infinify");return ce.assertValidity(),ce}hasHighS(){return v(this.s)}normalizeS(){return this.hasHighS()?new N(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return et(this.toDERHex())}toDERHex(){return se.hexFromSig(this)}toCompactRawBytes(){return et(this.toCompactHex())}toCompactHex(){const b=i;return wt(this.r,b)+wt(this.s,b)}}const P={isValidPrivateKey(g){try{return u(g),!0}catch{return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const g=fn(t.n);return ds(t.randomBytes(g),t.n)},precompute(g=8,b=d.BASE){return b._setWindowSize(g),b.multiply(BigInt(3)),b}};function y(g,b=!0){return d.fromPrivateKey(g).toRawBytes(b)}function l(g){if(typeof g=="bigint")return!1;if(g instanceof d)return!0;const E=Y("key",g).length,U=r.BYTES,O=U+1,H=2*U+1;if(!(t.allowedPrivateKeyLengths||i===O))return E===O||E===H}function p(g,b,E=!0){if(l(g)===!0)throw new Error("first arg must be private key");if(l(b)===!1)throw new Error("second arg must be public key");return d.fromHex(b).multiply(u(g)).toRawBytes(E)}const m=t.bits2int||function(g){if(g.length>8192)throw new Error("input is too large");const b=ye(g),E=g.length*8-s;return E>0?b>>BigInt(E):b},S=t.bits2int_modN||function(g){return c(m(g))},I=st(s);function $(g){return He("num < 2^"+s,g,oe,I),Re(g,i)}function k(g,b,E=B){if(["recovered","canonical"].some(he=>he in E))throw new Error("sign() legacy options not supported");const{hash:U,randomBytes:O}=t;let{lowS:H,prehash:_,extraEntropy:F}=E;H==null&&(H=!0),g=Y("msgHash",g),pr(E),_&&(g=Y("prehashed msgHash",U(g)));const ee=S(g),W=u(b),D=[$(W),$(ee)];if(F!=null&&F!==!1){const he=F===!0?O(r.BYTES):F;D.push(Y("extraEntropy",he))}const ve=tt(...D),ce=ee;function ct(he){const Be=m(he);if(!x(Be))return;const at=f(Be),ke=d.BASE.multiply(Be).toAffine(),pe=c(ke.x);if(pe===oe)return;const Ne=c(at*c(ce+pe*W));if(Ne===oe)return;let ze=(ke.x===pe?0:2)|Number(ke.y&T),Ae=Ne;return H&&v(Ne)&&(Ae=w(Ne),ze^=1),new N(pe,Ae,ze)}return{seed:ve,k2sig:ct}}const B={lowS:t.lowS,prehash:!1},C={lowS:t.lowS,prehash:!1};function A(g,b,E=B){const{seed:U,k2sig:O}=k(g,b,E),H=t;return mi(H.hash.outputLen,H.nByteLength,H.hmac)(U,O)}d.BASE._setWindowSize(8);function K(g,b,E,U=C){var ze;const O=g;b=Y("msgHash",b),E=Y("publicKey",E);const{lowS:H,prehash:_,format:F}=U;if(pr(U),"strict"in U)throw new Error("options.strict was renamed to lowS");if(F!==void 0&&F!=="compact"&&F!=="der")throw new Error("format must be compact or der");const ee=typeof O=="string"||Te(O),W=!ee&&!F&&typeof O=="object"&&O!==null&&typeof O.r=="bigint"&&typeof O.s=="bigint";if(!ee&&!W)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let D,ve;try{if(W&&(D=new N(O.r,O.s)),ee){try{F!=="compact"&&(D=N.fromDER(O))}catch(Ae){if(!(Ae instanceof se.Err))throw Ae}!D&&F!=="der"&&(D=N.fromCompact(O))}ve=d.fromHex(E)}catch{return!1}if(!D||H&&D.hasHighS())return!1;_&&(b=t.hash(b));const{r:ce,s:ct}=D,he=S(b),Be=f(ct),at=c(he*Be),ke=c(ce*Be),pe=(ze=d.BASE.multiplyAndAddUnsafe(ve,at,ke))==null?void 0:ze.toAffine();return pe?c(pe.x)===ce:!1}return{CURVE:t,getPublicKey:y,getSharedSecret:p,sign:A,verify:K,ProjectivePoint:d,Signature:N,utils:P}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Bs(e){return{hash:e,hmac:(t,...r)=>Ke(e,t,_e(...r)),randomBytes:zn}}function As(e,t){const r=n=>vs({...e,...Bs(n)});return{...r(t),create:r}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const hn=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),br=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Ss=BigInt(0),Is=BigInt(1),Ct=BigInt(2),gr=(e,t)=>(e+t/Ct)/t;function Os(e){const t=hn,r=BigInt(3),n=BigInt(6),i=BigInt(11),s=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),f=e*e*e%t,d=f*f*e%t,u=Z(d,r,t)*d%t,h=Z(u,r,t)*d%t,x=Z(h,Ct,t)*f%t,v=Z(x,i,t)*x%t,w=Z(v,s,t)*v%t,z=Z(w,a,t)*w%t,N=Z(z,c,t)*z%t,P=Z(N,a,t)*w%t,y=Z(P,r,t)*d%t,l=Z(y,o,t)*v%t,p=Z(l,n,t)*f%t,m=Z(p,Ct,t);if(!Ht.eql(Ht.sqr(m),e))throw new Error("Cannot find square root");return m}const Ht=qt(hn,void 0,void 0,{sqrt:Os}),Q=As({a:Ss,b:BigInt(7),Fp:Ht,n:br,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const t=br,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Is*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=r,o=BigInt("0x100000000000000000000000000000000"),a=gr(s*e,t),c=gr(-n*e,t);let f=M(e-a*r-c*i,t),d=M(-a*n-c*s,t);const u=f>o,h=d>o;if(u&&(f=t-f),h&&(d=t-d),f>o||d>o)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:u,k1:f,k2neg:h,k2:d}}}},Pt);/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function $t(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function pn(e,t){return Array.isArray(t)?t.length===0?!0:e?t.every(r=>typeof r=="string"):t.every(r=>Number.isSafeInteger(r)):!1}function Cs(e){if(typeof e!="function")throw new Error("function expected");return!0}function Ut(e,t){if(typeof t!="string")throw new Error(`${e}: string expected`);return!0}function Vt(e){if(!Number.isSafeInteger(e))throw new Error(`invalid integer: ${e}`)}function kt(e){if(!Array.isArray(e))throw new Error("array expected")}function bn(e,t){if(!pn(!0,t))throw new Error(`${e}: array of strings expected`)}function Hs(e,t){if(!pn(!1,t))throw new Error(`${e}: array of numbers expected`)}function gn(...e){const t=s=>s,r=(s,o)=>a=>s(o(a)),n=e.map(s=>s.encode).reduceRight(r,t),i=e.map(s=>s.decode).reduce(r,t);return{encode:n,decode:i}}function $s(e){const t=typeof e=="string"?e.split(""):e,r=t.length;bn("alphabet",t);const n=new Map(t.map((i,s)=>[i,s]));return{encode:i=>(kt(i),i.map(s=>{if(!Number.isSafeInteger(s)||s<0||s>=r)throw new Error(`alphabet.encode: digit index outside alphabet "${s}". Allowed: ${e}`);return t[s]})),decode:i=>(kt(i),i.map(s=>{Ut("alphabet.decode",s);const o=n.get(s);if(o===void 0)throw new Error(`Unknown letter: "${s}". Allowed: ${e}`);return o}))}}function Us(e=""){return Ut("join",e),{encode:t=>(bn("join.decode",t),t.join(e)),decode:t=>(Ut("join.decode",t),t.split(e))}}function wr(e,t,r){if(t<2)throw new Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);if(r<2)throw new Error(`convertRadix: invalid to=${r}, base cannot be less than 2`);if(kt(e),!e.length)return[];let n=0;const i=[],s=Array.from(e,a=>{if(Vt(a),a<0||a>=t)throw new Error(`invalid integer: ${a}`);return a}),o=s.length;for(;;){let a=0,c=!0;for(let f=n;f<o;f++){const d=s[f],u=t*a,h=u+d;if(!Number.isSafeInteger(h)||u/t!==a||h-d!==u)throw new Error("convertRadix: carry overflow");const x=h/r;a=h%r;const v=Math.floor(x);if(s[f]=v,!Number.isSafeInteger(v)||v*r+a!==h)throw new Error("convertRadix: carry overflow");if(c)v?c=!1:n=f;else continue}if(i.push(a),c)break}for(let a=0;a<e.length-1&&e[a]===0;a++)i.push(0);return i.reverse()}function ks(e){Vt(e);const t=2**8;return{encode:r=>{if(!$t(r))throw new Error("radix.encode input should be Uint8Array");return wr(Array.from(r),t,e)},decode:r=>(Hs("radix.decode",r),Uint8Array.from(wr(r,e,t)))}}function Ns(e,t){return Vt(e),Cs(t),{encode(r){if(!$t(r))throw new Error("checksum.encode: input should be Uint8Array");const n=t(r).slice(0,e),i=new Uint8Array(r.length+e);return i.set(r),i.set(n,r.length),i},decode(r){if(!$t(r))throw new Error("checksum.decode: input should be Uint8Array");const n=r.slice(0,-e),i=r.slice(-e),s=t(n).slice(0,e);for(let o=0;o<e;o++)if(s[o]!==i[o])throw new Error("Invalid checksum");return n}}}const zs=e=>gn(ks(58),$s(e),Us("")),Ls=zs("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),_s=e=>gn(Ns(4,t=>e(e(t))),Ls);/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */const Ye=Q.ProjectivePoint,yt=_s(Pt);function xr(e){q(e);const t=e.length===0?"0":Un(e);return BigInt("0x"+t)}function js(e){if(typeof e!="bigint")throw new Error("bigint expected");return kn(e.toString(16).padStart(64,"0"))}const Ps=zt("Bitcoin seed"),mt={private:76066276,public:76067358},Et=2147483648,Ks=e=>Vn(Pt(e)),Ts=e=>xe(e).getUint32(0,!1),We=e=>{if(!Number.isSafeInteger(e)||e<0||e>2**32-1)throw new Error("invalid number, should be from 0 to 2**32-1, got "+e);const t=new Uint8Array(4);return xe(t).setUint32(0,e,!1),t};class ge{get fingerprint(){if(!this.pubHash)throw new Error("No publicKey set!");return Ts(this.pubHash)}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this.privKeyBytes||null}get publicKey(){return this.pubKey||null}get privateExtendedKey(){const t=this.privateKey;if(!t)throw new Error("No private key");return yt.encode(this.serialize(this.versions.private,_e(new Uint8Array([0]),t)))}get publicExtendedKey(){if(!this.pubKey)throw new Error("No public key");return yt.encode(this.serialize(this.versions.public,this.pubKey))}static fromMasterSeed(t,r=mt){if(q(t),8*t.length<128||8*t.length>512)throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got "+t.length);const n=Ke(At,Ps,t);return new ge({versions:r,chainCode:n.slice(32),privateKey:n.slice(0,32)})}static fromExtendedKey(t,r=mt){const n=yt.decode(t),i=xe(n),s=i.getUint32(0,!1),o={versions:r,depth:n[4],parentFingerprint:i.getUint32(5,!1),index:i.getUint32(9,!1),chainCode:n.slice(13,45)},a=n.slice(45),c=a[0]===0;if(s!==r[c?"private":"public"])throw new Error("Version mismatch");return c?new ge({...o,privateKey:a.slice(1)}):new ge({...o,publicKey:a})}static fromJSON(t){return ge.fromExtendedKey(t.xpriv)}constructor(t){if(this.depth=0,this.index=0,this.chainCode=null,this.parentFingerprint=0,!t||typeof t!="object")throw new Error("HDKey.constructor must not be called directly");if(this.versions=t.versions||mt,this.depth=t.depth||0,this.chainCode=t.chainCode||null,this.index=t.index||0,this.parentFingerprint=t.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");if(t.publicKey&&t.privateKey)throw new Error("HDKey: publicKey and privateKey at same time.");if(t.privateKey){if(!Q.utils.isValidPrivateKey(t.privateKey))throw new Error("Invalid private key");this.privKey=typeof t.privateKey=="bigint"?t.privateKey:xr(t.privateKey),this.privKeyBytes=js(this.privKey),this.pubKey=Q.getPublicKey(t.privateKey,!0)}else if(t.publicKey)this.pubKey=Ye.fromHex(t.publicKey).toRawBytes(!0);else throw new Error("HDKey: no public or private key provided");this.pubHash=Ks(this.pubKey)}derive(t){if(!/^[mM]'?/.test(t))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(t))return this;const r=t.replace(/^[mM]'?\//,"").split("/");let n=this;for(const i of r){const s=/^(\d+)('?)$/.exec(i),o=s&&s[1];if(!s||s.length!==3||typeof o!="string")throw new Error("invalid child index: "+i);let a=+o;if(!Number.isSafeInteger(a)||a>=Et)throw new Error("Invalid index");s[2]==="'"&&(a+=Et),n=n.deriveChild(a)}return n}deriveChild(t){if(!this.pubKey||!this.chainCode)throw new Error("No publicKey or chainCode set");let r=We(t);if(t>=Et){const a=this.privateKey;if(!a)throw new Error("Could not derive hardened child key");r=_e(new Uint8Array([0]),a,r)}else r=_e(this.pubKey,r);const n=Ke(At,this.chainCode,r),i=xr(n.slice(0,32)),s=n.slice(32);if(!Q.utils.isValidPrivateKey(i))throw new Error("Tweak bigger than curve order");const o={versions:this.versions,chainCode:s,depth:this.depth+1,parentFingerprint:this.fingerprint,index:t};try{if(this.privateKey){const a=M(this.privKey+i,Q.CURVE.n);if(!Q.utils.isValidPrivateKey(a))throw new Error("The tweak was out of range or the resulted private key is invalid");o.privateKey=a}else{const a=Ye.fromHex(this.pubKey).add(Ye.fromPrivateKey(i));if(a.equals(Ye.ZERO))throw new Error("The tweak was equal to negative P, which made the result key invalid");o.publicKey=a.toRawBytes(!0)}return new ge(o)}catch{return this.deriveChild(t+1)}}sign(t){if(!this.privateKey)throw new Error("No privateKey set!");return q(t,32),Q.sign(t,this.privKey).toCompactRawBytes()}verify(t,r){if(q(t,32),q(r,64),!this.publicKey)throw new Error("No publicKey set!");let n;try{n=Q.Signature.fromCompact(r)}catch{return!1}return Q.verify(n,t,this.publicKey)}wipePrivateData(){return this.privKey=void 0,this.privKeyBytes&&(this.privKeyBytes.fill(0),this.privKeyBytes=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(t,r){if(!this.chainCode)throw new Error("No chainCode set");return q(r,33),_e(We(t),new Uint8Array([this.depth]),We(this.parentFingerprint),We(this.index),this.chainCode,r)}}function Rs(e){const{privateKey:t}=e,r=Q.ProjectivePoint.fromPrivateKey(Dr(t).slice(2));return Gi(r)}function wn(e){return{derive:t=>wn(e.derive(t)),depth:e.depth,identifier:me(e.identifier),index:e.index,privateKey:me(e.privateKey),privateExtendedKey:e.privateExtendedKey,publicKey:Rs({privateKey:e.privateKey}),publicExtendedKey:e.publicExtendedKey,versions:e.versions}}function Fs(e,t={}){const{versions:r}=t,n=ge.fromMasterSeed(Yr(e),r);return wn(n)}function Ms(e={}){const{account:t=0,change:r=0,index:n=0}=e;return`m/44'/60'/${t}'/${r}/${n}`}function qs(e,t,r,n){Ir(e);const i=Nn({dkLen:32,asyncTick:10},n),{c:s,dkLen:o,asyncTick:a}=i;if(de(s),de(o),de(a),s<1)throw new Error("iterations (c) should be >= 1");const c=Yt(t),f=Yt(r),d=new Uint8Array(o),u=Ke.create(e,c),h=u._cloneInto().update(f);return{c:s,dkLen:o,asyncTick:a,DK:d,PRF:u,PRFSalt:h}}function Vs(e,t,r,n,i){return e.destroy(),t.destroy(),n&&n.destroy(),X(i),r}function Ds(e,t,r,n){const{c:i,dkLen:s,DK:o,PRF:a,PRFSalt:c}=qs(e,t,r,n);let f;const d=new Uint8Array(4),u=xe(d),h=new Uint8Array(a.outputLen);for(let x=1,v=0;v<s;x++,v+=a.outputLen){const w=o.subarray(v,v+a.outputLen);u.setInt32(0,x,!1),(f=c._cloneInto(f)).update(d).digestInto(h),w.set(h.subarray(0,w.length));for(let z=1;z<i;z++){a._cloneInto(f).update(h).digestInto(h);for(let N=0;N<w.length;N++)w[N]^=h[N]}}return Vs(a,c,o,f,h)}/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */function xn(e){if(typeof e!="string")throw new TypeError("invalid mnemonic type: "+typeof e);return e.normalize("NFKD")}function Gs(e){const t=xn(e),r=t.split(" ");if(![12,15,18,21,24].includes(r.length))throw new Error("Invalid mnemonic");return{nfkd:t,words:r}}const Zs=e=>xn("mnemonic"+e);function Ys(e,t=""){return Ds(At,Gs(e).nfkd,Zs(t),{c:2048,dkLen:64})}function Ws(e,t={}){const{passphrase:r}=t,n=Xs(e,{passphrase:r});return Fs(n)}function Xs(e,t={}){const{passphrase:r}=t,n=Ys(e,r);return t.as==="Hex"?Ri(n):n}const Nt=1e3,$e=64,vt=$e/2,Js="gradient-avatar-",Qs=En(["shrink-0 rounded-full overflow-hidden"],{variants:{size:{xs:"w-3 h-3",sm:"w-5 h-5",md:"w-8 h-8",lg:"w-10 h-10",xl:"w-[52px] h-[52px]"}},defaultVariants:{size:"md"}}),Bt=(e,t=Nt)=>e%t/(Nt/$e),Ce=(e,t=0)=>{let r=3735928559^t,n=1103547991^t;for(let i=0,s;i<e.length;i++)s=e.charCodeAt(i),r=Math.imul(r^s,2654435761),n=Math.imul(n^s,1597334677);return r=Math.imul(r^r>>>16,2246822507)^Math.imul(n^n>>>13,3266489909),n=Math.imul(n^n>>>16,2246822507)^Math.imul(r^r>>>13,3266489909),4294967296*(2097151&n)+(r>>>0)},Qe=(e,t)=>`${Js}${e}${t}`,eo=(e,t,r)=>{const n=e%360,i=(e+120)%360,s=r%360;return{hueA:n,hueB:i,hueC:s}},to=(e,t)=>{const r={a:Ce(t+"a",0),b:Ce(t+"b",1),c:Ce(t+"c",2),x:Ce(t+"d",3),y:Ce(t+"e",4),r:Ce(t+"f",5)},{hueA:n,hueB:i,hueC:s}=eo(r.a,r.b,r.c),o=Bt(r.x),a=Bt(r.y),c=$e/10+Bt(r.r,Nt*1.5);return{background:{id:Qe("background",e),stopColor0:`hsl(${s}deg 100% 50% / 1)`,stopColor1:`hsl(${n}deg 100% 50% / 1)`,cx:o,cy:a,r:c},primary:{id:Qe("primary",e),stopColor0:`hsl(${n}deg 100% 50% / 1)`,stopColor1:`hsl(${i}deg 100% 50% / 1)`,cx:o,cy:a,r:c},secondary:{id:Qe("secondary",e),stopColor0:`hsl(${s}deg 100% 50% / 1)`,stopColor1:`hsl(${i}deg 100% 50% / 1)`,cx:a,cy:o,r:c/2}}},rt=Dt.memo(e=>{const{className:t,address:r,size:n="md",...i}=e,s=Dt.useId(),o=to(s,r.toLowerCase()),a=c=>Qe(c,s);return L.jsxs("svg",{className:vn(Qs({size:n}),t),viewBox:`0 0 ${$e} ${$e}`,version:"1.1",xmlns:"http://www.w3.org/2000/svg",...i,children:[L.jsxs("defs",{children:[L.jsx("clipPath",{id:a("circle-clip"),children:L.jsx("circle",{cx:vt,cy:vt,r:vt})}),L.jsxs("filter",{id:a("blur-xs"),x:"-10%",y:"-10%",width:"120%",height:"120%",filterUnits:"userSpaceOnUse",colorInterpolationFilters:"sRGB",children:[L.jsx("feFlood",{floodOpacity:"0",result:"BackgroundImageFix"}),L.jsx("feBlend",{mode:"normal",in:"SourceGraphic",in2:"BackgroundImageFix",result:"shape"}),L.jsx("feGaussianBlur",{stdDeviation:$e/10,result:"effect1_foregroundBlur"})]}),L.jsxs("linearGradient",{id:o.background.id,x1:"0",y1:"0",x2:"1",y2:"1",children:[L.jsx("stop",{offset:"0",stopColor:o.background.stopColor0}),L.jsx("stop",{offset:"1",stopColor:o.background.stopColor1})]}),L.jsxs("radialGradient",{id:o.primary.id,children:[L.jsx("stop",{offset:"0",stopColor:o.primary.stopColor0}),L.jsx("stop",{offset:"1",stopColor:o.primary.stopColor1})]}),L.jsxs("radialGradient",{id:o.secondary.id,children:[L.jsx("stop",{offset:"0",stopColor:o.secondary.stopColor0}),L.jsx("stop",{offset:"1",stopColor:o.secondary.stopColor1})]})]}),L.jsxs("g",{clipPath:`url(#${a("circle-clip")})`,children:[L.jsx("rect",{width:"100%",height:"100%",fill:`url(#${o.background.id})`}),L.jsxs("g",{filter:`url(#${a("blur-xs")})`,children:[L.jsx("circle",{fill:`url(#${o.primary.id})`,cx:o.primary.cx,cy:o.primary.cy,r:o.primary.r}),L.jsx("circle",{fill:`url(#${o.secondary.id})`,cx:o.secondary.cx,cy:o.secondary.cy,r:o.secondary.r})]})]})]})});try{rt.displayName="GradientAvatar",rt.__docgenInfo={description:"",displayName:"GradientAvatar",props:{address:{defaultValue:null,description:"",name:"address",required:!0,type:{name:"string"}},className:{defaultValue:null,description:"",name:"className",required:!1,type:{name:"string"}},size:{defaultValue:null,description:"",name:"size",required:!1,type:{name:'"sm" | "md" | "lg" | "xs" | "xl" | null'}}}}}catch{}const ro="bulb cute board file buddy subway memory exercise busy repair foam item",bo={title:"Components/GradientAvatar",component:rt},Xe={args:{address:"0x1234567890123456789012345678901234567890"}},no=3,io=8,yn=[["0x8e3E38fe7367dd3b52D1e281E4e8400447C8d8B9","0x73F8E47dEe63002378E047fA74e6DFb24F88f496","0x9Cb019C2FfcD9E9BB83e269625a170179Ff3ECD0","0x9b436D9599FAc498e1e0Ab4D48cDFC72922a6F1e","0x9aB58Bda3eeCbF391a17592ed7626727b922a18f","0x468E8e29F6cfb0F6b7ff10ec6A1AB516ec849c04","0x450cB9fbB2D44d166AACA1f6cDb1dBd9Ff168e4C","0x88cc3E896C4C178AB98333dCD29C33d2cc2102A8"],["0x8e3E38fe7367dd3b52D1e281E4e8400447C8d8Bx","0x73F8E47dEe63002378E047fA74e6DFb24F88f49x","0x9Cb019C2FfcD9E9BB83e269625a170179Ff3ECDx","0x9b436D9599FAc498e1e0Ab4D48cDFC72922a6F1x","0x9aB58Bda3eeCbF391a17592ed7626727b922a18x","0x468E8e29F6cfb0F6b7ff10ec6A1AB516ec849c0x","0x450cB9fbB2D44d166AACA1f6cDb1dBd9Ff168e4x","0x88cc3E896C4C178AB98333dCD29C33d2cc2102Ax"]],so=(e,t,r)=>{const{publicKey:n}=Ws(e).derive(Ms({account:t,change:r})),i=rs(n);return Mt(i)};for(let e=0;e<no;e++){const t=[];for(let r=0;r<io;r++)t.push(so(ro,e,r));yn.push(t)}const Je=()=>L.jsxs(L.Fragment,{children:[L.jsx(mn,{variant:"normal",color:"primary",fontWeight:"bold",asChild:!0,children:L.jsx("div",{children:"SVG"})}),L.jsx("div",{className:"flex flex-col gap-4",children:yn.map((e,t)=>L.jsx("div",{className:"flex gap-4",children:e.map(r=>L.jsx(rt,{address:r,size:"xl"},r))},t))})]});var yr,mr,Er;Xe.parameters={...Xe.parameters,docs:{...(yr=Xe.parameters)==null?void 0:yr.docs,source:{originalSource:`{
  args: {
    address: '0x1234567890123456789012345678901234567890'
  }
}`,...(Er=(mr=Xe.parameters)==null?void 0:mr.docs)==null?void 0:Er.source}}};var vr,Br,Ar;Je.parameters={...Je.parameters,docs:{...(vr=Je.parameters)==null?void 0:vr.docs,source:{originalSource:`() => {
  return <>
      <Text variant="normal" color="primary" fontWeight="bold" asChild>
        <div>SVG</div>
      </Text>

      <div className="flex flex-col gap-4">
        {rows.map((cols, idx) => <div className="flex gap-4" key={idx}>
            {cols.map(address => <GradientAvatar key={address} address={address} size="xl" />)}
          </div>)}
      </div>
    </>;
}`,...(Ar=(Br=Je.parameters)==null?void 0:Br.docs)==null?void 0:Ar.source}}};const go=["Default","Multiple"];export{Xe as Default,Je as Multiple,go as __namedExportsOrder,bo as default};
