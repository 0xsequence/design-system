import{j as L}from"./jsx-runtime-D_zvdyIk.js";import{T as fn}from"./Text-ZXzJZT7u.js";import{c as un}from"./index-Dp3B9jqt.js";import{r as Pe}from"./index-CFahbR6w.js";import{c as ln}from"./classnames-BovuWA26.js";import"./index-B2_zDxcN.js";import"./clsx-B-dksMZM.js";const dn="0.1.1";function hn(){return dn}class K extends Error{constructor(t,r={}){const n=(()=>{var a;if(r.cause instanceof K){if(r.cause.details)return r.cause.details;if(r.cause.shortMessage)return r.cause.shortMessage}return r.cause&&"details"in r.cause&&typeof r.cause.details=="string"?r.cause.details:(a=r.cause)!=null&&a.message?r.cause.message:r.details})(),i=r.cause instanceof K&&r.cause.docsPath||r.docsPath,o=`https://oxlib.sh${i??""}`,c=[t||"An error occurred.",...r.metaMessages?["",...r.metaMessages]:[],...n||i?["",n?`Details: ${n}`:void 0,i?`See: ${o}`:void 0]:[]].filter(a=>typeof a=="string").join(`
`);super(c,r.cause?{cause:r.cause}:void 0),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"BaseError"}),Object.defineProperty(this,"version",{enumerable:!0,configurable:!0,writable:!0,value:`ox@${hn()}`}),this.cause=r.cause,this.details=n,this.docs=o,this.docsPath=i,this.shortMessage=t}walk(t){return wr(this,t)}}function wr(e,t){return t!=null&&t(e)?e:e&&typeof e=="object"&&"cause"in e&&e.cause?wr(e.cause,t):t?null:e}function be(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function pn(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function G(e,...t){if(!pn(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function xr(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");be(e.outputLen),be(e.blockLen)}function He(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function yr(e,t){G(e);const r=t.outputLen;if(e.length<r)throw new Error("digestInto() expects output buffer of length at least "+r)}const Be=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function bn(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}function ge(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function X(e,t){return e<<32-t|e>>>t}function _e(e,t){return e<<t|e>>>32-t>>>0}const _t=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function gn(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}function Tt(e){for(let t=0;t<e.length;t++)e[t]=gn(e[t])}const mr=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",wn=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function xn(e){if(G(e),mr)return e.toHex();let t="";for(let r=0;r<e.length;r++)t+=wn[e[r]];return t}const ee={_0:48,_9:57,A:65,F:70,a:97,f:102};function Rt(e){if(e>=ee._0&&e<=ee._9)return e-ee._0;if(e>=ee.A&&e<=ee.F)return e-(ee.A-10);if(e>=ee.a&&e<=ee.f)return e-(ee.a-10)}function yn(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);if(mr)return Uint8Array.fromHex(e);const t=e.length,r=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(r);for(let i=0,s=0;i<r;i++,s+=2){const o=Rt(e.charCodeAt(s)),c=Rt(e.charCodeAt(s+1));if(o===void 0||c===void 0){const a=e[s]+e[s+1];throw new Error('hex string expected, got non-hex character "'+a+'" at index '+s)}n[i]=o*16+c}return n}function Er(e){if(typeof e!="string")throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array(new TextEncoder().encode(e))}function $e(e){return typeof e=="string"&&(e=Er(e)),G(e),e}function Ne(...e){let t=0;for(let n=0;n<e.length;n++){const i=e[n];G(i),t+=i.length}const r=new Uint8Array(t);for(let n=0,i=0;n<e.length;n++){const s=e[n];r.set(s,i),i+=s.length}return r}class $t{clone(){return this._cloneInto()}}function mn(e,t){if(t!==void 0&&{}.toString.call(t)!=="[object Object]")throw new Error("Options should be object or undefined");return Object.assign(e,t)}function Je(e){const t=n=>e().update($e(n)).digest(),r=e();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>e(),t}function En(e=32){if(Be&&typeof Be.getRandomValues=="function")return Be.getRandomValues(new Uint8Array(e));if(Be&&typeof Be.randomBytes=="function")return Uint8Array.from(Be.randomBytes(e));throw new Error("crypto.getRandomValues must be defined")}function vn(e,t,r,n){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,r,n);const i=BigInt(32),s=BigInt(4294967295),o=Number(r>>i&s),c=Number(r&s),a=n?4:0,f=n?0:4;e.setUint32(t+a,o,n),e.setUint32(t+f,c,n)}function Bn(e,t,r){return e&t^~e&r}function An(e,t,r){return e&t^e&r^t&r}class Ot extends $t{constructor(t,r,n,i){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=t,this.outputLen=r,this.padOffset=n,this.isLE=i,this.buffer=new Uint8Array(t),this.view=ge(this.buffer)}update(t){He(this);const{view:r,buffer:n,blockLen:i}=this;t=$e(t);const s=t.length;for(let o=0;o<s;){const c=Math.min(i-this.pos,s-o);if(c===i){const a=ge(t);for(;i<=s-o;o+=i)this.process(a,o);continue}n.set(t.subarray(o,o+c),this.pos),this.pos+=c,o+=c,this.pos===i&&(this.process(r,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){He(this),yr(t,this),this.finished=!0;const{buffer:r,view:n,blockLen:i,isLE:s}=this;let{pos:o}=this;r[o++]=128,this.buffer.subarray(o).fill(0),this.padOffset>i-o&&(this.process(n,0),o=0);for(let d=o;d<i;d++)r[d]=0;vn(n,i-8,BigInt(this.length*8),s),this.process(n,0);const c=ge(t),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const f=a/4,h=this.get();if(f>h.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<f;d++)c.setUint32(4*d,h[d],s)}digest(){const{buffer:t,outputLen:r}=this;this.digestInto(t);const n=t.slice(0,r);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:r,buffer:n,length:i,finished:s,destroyed:o,pos:c}=this;return t.length=i,t.pos=c,t.finished=s,t.destroyed=o,i%r&&t.buffer.set(n),t}}const Sn=new Uint8Array([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),vr=new Uint8Array(new Array(16).fill(0).map((e,t)=>t)),In=vr.map(e=>(9*e+5)%16);let Ct=[vr],Ut=[In];for(let e=0;e<4;e++)for(let t of[Ct,Ut])t.push(t[e].map(r=>Sn[r]));const Br=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(e=>new Uint8Array(e)),Hn=Ct.map((e,t)=>e.map(r=>Br[t][r])),$n=Ut.map((e,t)=>e.map(r=>Br[t][r])),On=new Uint32Array([0,1518500249,1859775393,2400959708,2840853838]),Cn=new Uint32Array([1352829926,1548603684,1836072691,2053994217,0]);function Mt(e,t,r,n){return e===0?t^r^n:e===1?t&r|~t&n:e===2?(t|~r)^n:e===3?t&n|r&~n:t^(r|~n)}const Te=new Uint32Array(16);class Un extends Ot{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:t,h1:r,h2:n,h3:i,h4:s}=this;return[t,r,n,i,s]}set(t,r,n,i,s){this.h0=t|0,this.h1=r|0,this.h2=n|0,this.h3=i|0,this.h4=s|0}process(t,r){for(let p=0;p<16;p++,r+=4)Te[p]=t.getUint32(r,!0);let n=this.h0|0,i=n,s=this.h1|0,o=s,c=this.h2|0,a=c,f=this.h3|0,h=f,d=this.h4|0,l=d;for(let p=0;p<5;p++){const B=4-p,w=On[p],u=Cn[p],b=Ct[p],E=Ut[p],g=Hn[p],H=$n[p];for(let A=0;A<16;A++){const $=_e(n+Mt(p,s,c,f)+Te[b[A]]+w,g[A])+d|0;n=d,d=f,f=_e(c,10)|0,c=s,s=$}for(let A=0;A<16;A++){const $=_e(i+Mt(B,o,a,h)+Te[E[A]]+u,H[A])+l|0;i=l,l=h,h=_e(a,10)|0,a=o,o=$}}this.set(this.h1+c+h|0,this.h2+f+l|0,this.h3+d+i|0,this.h4+n+o|0,this.h0+s+a|0)}roundClean(){Te.fill(0)}destroy(){this.destroyed=!0,this.buffer.fill(0),this.set(0,0,0,0,0)}}const kn=Je(()=>new Un),Re=BigInt(2**32-1),gt=BigInt(32);function Ar(e,t=!1){return t?{h:Number(e&Re),l:Number(e>>gt&Re)}:{h:Number(e>>gt&Re)|0,l:Number(e&Re)|0}}function Sr(e,t=!1){let r=new Uint32Array(e.length),n=new Uint32Array(e.length);for(let i=0;i<e.length;i++){const{h:s,l:o}=Ar(e[i],t);[r[i],n[i]]=[s,o]}return[r,n]}const Ln=(e,t)=>BigInt(e>>>0)<<gt|BigInt(t>>>0),Nn=(e,t,r)=>e>>>r,zn=(e,t,r)=>e<<32-r|t>>>r,jn=(e,t,r)=>e>>>r|t<<32-r,Kn=(e,t,r)=>e<<32-r|t>>>r,Fn=(e,t,r)=>e<<64-r|t>>>r-32,Pn=(e,t,r)=>e>>>r-32|t<<64-r,_n=(e,t)=>t,Tn=(e,t)=>e,Ir=(e,t,r)=>e<<r|t>>>32-r,Hr=(e,t,r)=>t<<r|e>>>32-r,$r=(e,t,r)=>t<<r-32|e>>>64-r,Or=(e,t,r)=>e<<r-32|t>>>64-r;function Rn(e,t,r,n){const i=(t>>>0)+(n>>>0);return{h:e+r+(i/2**32|0)|0,l:i|0}}const Mn=(e,t,r)=>(e>>>0)+(t>>>0)+(r>>>0),qn=(e,t,r,n)=>t+r+n+(e/2**32|0)|0,Vn=(e,t,r,n)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0),Dn=(e,t,r,n,i)=>t+r+n+i+(e/2**32|0)|0,Gn=(e,t,r,n,i)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0)+(i>>>0),Zn=(e,t,r,n,i,s)=>t+r+n+i+s+(e/2**32|0)|0,O={fromBig:Ar,split:Sr,toBig:Ln,shrSH:Nn,shrSL:zn,rotrSH:jn,rotrSL:Kn,rotrBH:Fn,rotrBL:Pn,rotr32H:_n,rotr32L:Tn,rotlSH:Ir,rotlSL:Hr,rotlBH:$r,rotlBL:Or,add:Rn,add3L:Mn,add3H:qn,add4L:Vn,add4H:Dn,add5H:Zn,add5L:Gn},Cr=[],Ur=[],kr=[],Wn=BigInt(0),Le=BigInt(1),Yn=BigInt(2),Xn=BigInt(7),Jn=BigInt(256),Qn=BigInt(113);for(let e=0,t=Le,r=1,n=0;e<24;e++){[r,n]=[n,(2*r+3*n)%5],Cr.push(2*(5*n+r)),Ur.push((e+1)*(e+2)/2%64);let i=Wn;for(let s=0;s<7;s++)t=(t<<Le^(t>>Xn)*Qn)%Jn,t&Yn&&(i^=Le<<(Le<<BigInt(s))-Le);kr.push(i)}const[ei,ti]=Sr(kr,!0),qt=(e,t,r)=>r>32?$r(e,t,r):Ir(e,t,r),Vt=(e,t,r)=>r>32?Or(e,t,r):Hr(e,t,r);function ri(e,t=24){const r=new Uint32Array(10);for(let n=24-t;n<24;n++){for(let o=0;o<10;o++)r[o]=e[o]^e[o+10]^e[o+20]^e[o+30]^e[o+40];for(let o=0;o<10;o+=2){const c=(o+8)%10,a=(o+2)%10,f=r[a],h=r[a+1],d=qt(f,h,1)^r[c],l=Vt(f,h,1)^r[c+1];for(let p=0;p<50;p+=10)e[o+p]^=d,e[o+p+1]^=l}let i=e[2],s=e[3];for(let o=0;o<24;o++){const c=Ur[o],a=qt(i,s,c),f=Vt(i,s,c),h=Cr[o];i=e[h],s=e[h+1],e[h]=a,e[h+1]=f}for(let o=0;o<50;o+=10){for(let c=0;c<10;c++)r[c]=e[o+c];for(let c=0;c<10;c++)e[o+c]^=~r[(c+2)%10]&r[(c+4)%10]}e[0]^=ei[n],e[1]^=ti[n]}r.fill(0)}class kt extends $t{constructor(t,r,n,i=!1,s=24){if(super(),this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,this.enableXOF=!1,this.blockLen=t,this.suffix=r,this.outputLen=n,this.enableXOF=i,this.rounds=s,be(n),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=bn(this.state)}keccak(){_t||Tt(this.state32),ri(this.state32,this.rounds),_t||Tt(this.state32),this.posOut=0,this.pos=0}update(t){He(this);const{blockLen:r,state:n}=this;t=$e(t);const i=t.length;for(let s=0;s<i;){const o=Math.min(r-this.pos,i-s);for(let c=0;c<o;c++)n[this.pos++]^=t[s++];this.pos===r&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:r,pos:n,blockLen:i}=this;t[n]^=r,(r&128)!==0&&n===i-1&&this.keccak(),t[i-1]^=128,this.keccak()}writeInto(t){He(this,!1),G(t),this.finish();const r=this.state,{blockLen:n}=this;for(let i=0,s=t.length;i<s;){this.posOut>=n&&this.keccak();const o=Math.min(n-this.posOut,s-i);t.set(r.subarray(this.posOut,this.posOut+o),i),this.posOut+=o,i+=o}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return be(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(yr(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:r,suffix:n,outputLen:i,rounds:s,enableXOF:o}=this;return t||(t=new kt(r,n,i,o,s)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=s,t.suffix=n,t.outputLen=i,t.enableXOF=o,t.destroyed=this.destroyed,t}}const ni=(e,t,r)=>Je(()=>new kt(t,e,r)),ii=ni(1,136,256/8),si=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),oe=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ce=new Uint32Array(64);class oi extends Ot{constructor(t=32){super(64,t,8,!1),this.A=oe[0]|0,this.B=oe[1]|0,this.C=oe[2]|0,this.D=oe[3]|0,this.E=oe[4]|0,this.F=oe[5]|0,this.G=oe[6]|0,this.H=oe[7]|0}get(){const{A:t,B:r,C:n,D:i,E:s,F:o,G:c,H:a}=this;return[t,r,n,i,s,o,c,a]}set(t,r,n,i,s,o,c,a){this.A=t|0,this.B=r|0,this.C=n|0,this.D=i|0,this.E=s|0,this.F=o|0,this.G=c|0,this.H=a|0}process(t,r){for(let d=0;d<16;d++,r+=4)ce[d]=t.getUint32(r,!1);for(let d=16;d<64;d++){const l=ce[d-15],p=ce[d-2],B=X(l,7)^X(l,18)^l>>>3,w=X(p,17)^X(p,19)^p>>>10;ce[d]=w+ce[d-7]+B+ce[d-16]|0}let{A:n,B:i,C:s,D:o,E:c,F:a,G:f,H:h}=this;for(let d=0;d<64;d++){const l=X(c,6)^X(c,11)^X(c,25),p=h+l+Bn(c,a,f)+si[d]+ce[d]|0,w=(X(n,2)^X(n,13)^X(n,22))+An(n,i,s)|0;h=f,f=a,a=c,c=o+p|0,o=s,s=i,i=n,n=p+w|0}n=n+this.A|0,i=i+this.B|0,s=s+this.C|0,o=o+this.D|0,c=c+this.E|0,a=a+this.F|0,f=f+this.G|0,h=h+this.H|0,this.set(n,i,s,o,c,a,f,h)}roundClean(){ce.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Lt=Je(()=>new oi);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Nt=BigInt(0),wt=BigInt(1);function Oe(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function zt(e){if(!Oe(e))throw new Error("Uint8Array expected")}function ze(e,t){if(typeof t!="boolean")throw new Error(e+" boolean expected, got "+t)}function Me(e){const t=e.toString(16);return t.length&1?"0"+t:t}function Lr(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?Nt:BigInt("0x"+e)}const Nr=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",ci=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function je(e){if(zt(e),Nr)return e.toHex();let t="";for(let r=0;r<e.length;r++)t+=ci[e[r]];return t}const te={_0:48,_9:57,A:65,F:70,a:97,f:102};function Dt(e){if(e>=te._0&&e<=te._9)return e-te._0;if(e>=te.A&&e<=te.F)return e-(te.A-10);if(e>=te.a&&e<=te.f)return e-(te.a-10)}function We(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);if(Nr)return Uint8Array.fromHex(e);const t=e.length,r=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(r);for(let i=0,s=0;i<r;i++,s+=2){const o=Dt(e.charCodeAt(s)),c=Dt(e.charCodeAt(s+1));if(o===void 0||c===void 0){const a=e[s]+e[s+1];throw new Error('hex string expected, got non-hex character "'+a+'" at index '+s)}n[i]=o*16+c}return n}function we(e){return Lr(je(e))}function zr(e){return zt(e),Lr(je(Uint8Array.from(e).reverse()))}function Ke(e,t){return We(e.toString(16).padStart(t*2,"0"))}function jr(e,t){return Ke(e,t).reverse()}function W(e,t,r){let n;if(typeof t=="string")try{n=We(t)}catch(s){throw new Error(e+" must be hex string or Uint8Array, cause: "+s)}else if(Oe(t))n=Uint8Array.from(t);else throw new Error(e+" must be hex string or Uint8Array");const i=n.length;if(typeof r=="number"&&i!==r)throw new Error(e+" of length "+r+" expected, got "+i);return n}function Ye(...e){let t=0;for(let n=0;n<e.length;n++){const i=e[n];zt(i),t+=i.length}const r=new Uint8Array(t);for(let n=0,i=0;n<e.length;n++){const s=e[n];r.set(s,i),i+=s.length}return r}const nt=e=>typeof e=="bigint"&&Nt<=e;function jt(e,t,r){return nt(e)&&nt(t)&&nt(r)&&t<=e&&e<r}function Se(e,t,r,n){if(!jt(t,r,n))throw new Error("expected valid "+e+": "+r+" <= n < "+n+", got "+t)}function ai(e){let t;for(t=0;e>Nt;e>>=wt,t+=1);return t}const Qe=e=>(wt<<BigInt(e))-wt,it=e=>new Uint8Array(e),Gt=e=>Uint8Array.from(e);function fi(e,t,r){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof r!="function")throw new Error("hmacFn must be a function");let n=it(e),i=it(e),s=0;const o=()=>{n.fill(1),i.fill(0),s=0},c=(...d)=>r(i,n,...d),a=(d=it(0))=>{i=c(Gt([0]),d),n=c(),d.length!==0&&(i=c(Gt([1]),d),n=c())},f=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let d=0;const l=[];for(;d<t;){n=c();const p=n.slice();l.push(p),d+=n.length}return Ye(...l)};return(d,l)=>{o(),a(d);let p;for(;!(p=l(f()));)a();return o(),p}}const ui={bigint:e=>typeof e=="bigint",function:e=>typeof e=="function",boolean:e=>typeof e=="boolean",string:e=>typeof e=="string",stringOrUint8Array:e=>typeof e=="string"||Oe(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>typeof e=="function"&&Number.isSafeInteger(e.outputLen)};function et(e,t,r={}){const n=(i,s,o)=>{const c=ui[s];if(typeof c!="function")throw new Error("invalid validator function");const a=e[i];if(!(o&&a===void 0)&&!c(a,e))throw new Error("param "+String(i)+" is invalid. Expected "+s+", got "+a)};for(const[i,s]of Object.entries(t))n(i,s,!1);for(const[i,s]of Object.entries(r))n(i,s,!0);return e}function Zt(e){const t=new WeakMap;return(r,...n)=>{const i=t.get(r);if(i!==void 0)return i;const s=e(r,...n);return t.set(r,s),s}}const li="#__bigint";function Kt(e,t,r){return JSON.stringify(e,(n,i)=>typeof i=="bigint"?i.toString()+li:i,r)}function di(e,t){if(Jt(e)>t)throw new ki({givenSize:Jt(e),maxSize:t})}const re={zero:48,nine:57,A:65,F:70,a:97,f:102};function Wt(e){if(e>=re.zero&&e<=re.nine)return e-re.zero;if(e>=re.A&&e<=re.F)return e-(re.A-10);if(e>=re.a&&e<=re.f)return e-(re.a-10)}function hi(e,t={}){const{dir:r,size:n=32}=t;if(n===0)return e;if(e.length>n)throw new Li({size:e.length,targetSize:n,type:"Bytes"});const i=new Uint8Array(n);for(let s=0;s<n;s++){const o=r==="right";i[o?s:n-s-1]=e[o?s:e.length-s-1]}return i}function Kr(e,t){if(ye(e)>t)throw new vi({givenSize:ye(e),maxSize:t})}function pi(e,t){if(typeof t=="number"&&t>0&&t>ye(e)-1)throw new Tr({offset:t,position:"start",size:ye(e)})}function bi(e,t,r){if(typeof t=="number"&&typeof r=="number"&&ye(e)!==r-t)throw new Tr({offset:r,position:"end",size:ye(e)})}function Fr(e,t={}){const{dir:r,size:n=32}=t;if(n===0)return e;const i=e.replace("0x","");if(i.length>n*2)throw new Bi({size:Math.ceil(i.length/2),targetSize:n,type:"Hex"});return`0x${i[r==="right"?"padEnd":"padStart"](n*2,"0")}`}const gi=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function wi(e,t={}){const{strict:r=!1}=t;if(!e)throw new Yt(e);if(typeof e!="string")throw new Yt(e);if(r&&!/^0x[0-9a-fA-F]*$/.test(e))throw new Xt(e);if(!e.startsWith("0x"))throw new Xt(e)}function xi(...e){return`0x${e.reduce((t,r)=>t+r.replace("0x",""),"")}`}function Pr(e){return e instanceof Uint8Array?xe(e):Array.isArray(e)?xe(new Uint8Array(e)):e}function xe(e,t={}){let r="";for(let i=0;i<e.length;i++)r+=gi[e[i]];const n=`0x${r}`;return typeof t.size=="number"?(Kr(n,t.size),_r(n,t.size)):n}function st(e,t={}){const{signed:r,size:n}=t,i=BigInt(e);let s;n?r?s=(1n<<BigInt(n)*8n-1n)-1n:s=2n**(BigInt(n)*8n)-1n:typeof e=="number"&&(s=BigInt(Number.MAX_SAFE_INTEGER));const o=typeof s=="bigint"&&r?-s-1n:0;if(s&&i>s||i<o){const f=typeof e=="bigint"?"n":"";throw new Ei({max:s?`${s}${f}`:void 0,min:`${o}${f}`,signed:r,size:n,value:`${e}${f}`})}const a=`0x${(r&&i<0?(1n<<BigInt(n*8))+BigInt(i):i).toString(16)}`;return n?yi(a,n):a}function yi(e,t){return Fr(e,{dir:"left",size:t})}function _r(e,t){return Fr(e,{dir:"right",size:t})}function de(e,t,r,n={}){const{strict:i}=n;pi(e,t);const s=`0x${e.replace("0x","").slice((t??0)*2,(r??e.length)*2)}`;return i&&bi(s,t,r),s}function ye(e){return Math.ceil((e.length-2)/2)}function mi(e,t={}){const{strict:r=!1}=t;try{return wi(e,{strict:r}),!0}catch{return!1}}class Ei extends K{constructor({max:t,min:r,signed:n,size:i,value:s}){super(`Number \`${s}\` is not in safe${i?` ${i*8}-bit`:""}${n?" signed":" unsigned"} integer range ${t?`(\`${r}\` to \`${t}\`)`:`(above \`${r}\`)`}`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Hex.IntegerOutOfRangeError"})}}class Yt extends K{constructor(t){super(`Value \`${typeof t=="object"?Kt(t):t}\` of type \`${typeof t}\` is an invalid hex type.`,{metaMessages:['Hex types must be represented as `"0x${string}"`.']}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Hex.InvalidHexTypeError"})}}class Xt extends K{constructor(t){super(`Value \`${t}\` is an invalid hex value.`,{metaMessages:['Hex values must start with `"0x"` and contain only hexadecimal characters (0-9, a-f, A-F).']}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Hex.InvalidHexValueError"})}}let vi=class extends K{constructor({givenSize:t,maxSize:r}){super(`Size cannot exceed \`${r}\` bytes. Given size: \`${t}\` bytes.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Hex.SizeOverflowError"})}};class Tr extends K{constructor({offset:t,position:r,size:n}){super(`Slice ${r==="start"?"starting":"ending"} at offset \`${t}\` is out-of-bounds (size: \`${n}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Hex.SliceOffsetOutOfBoundsError"})}}let Bi=class extends K{constructor({size:t,targetSize:r,type:n}){super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (\`${t}\`) exceeds padding size (\`${r}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Hex.SizeExceedsPaddingSizeError"})}};const Ai=new TextEncoder;function Si(e){if(!(e instanceof Uint8Array)){if(!e)throw new qe(e);if(typeof e!="object")throw new qe(e);if(!("BYTES_PER_ELEMENT"in e))throw new qe(e);if(e.BYTES_PER_ELEMENT!==1||e.constructor.name!=="Uint8Array")throw new qe(e)}}function Rr(e){return e instanceof Uint8Array?e:typeof e=="string"?Hi(e):Ii(e)}function Ii(e){return e instanceof Uint8Array?e:new Uint8Array(e)}function Hi(e,t={}){const{size:r}=t;let n=e;r&&(Kr(e,r),n=_r(e,r));let i=n.slice(2);i.length%2&&(i=`0${i}`);const s=i.length/2,o=new Uint8Array(s);for(let c=0,a=0;c<s;c++){const f=Wt(i.charCodeAt(a++)),h=Wt(i.charCodeAt(a++));if(f===void 0||h===void 0)throw new K(`Invalid byte sequence ("${i[a-2]}${i[a-1]}" in "${i}").`);o[c]=f*16+h}return o}function $i(e,t={}){const{size:r}=t,n=Ai.encode(e);return typeof r=="number"?(di(n,r),Oi(n,r)):n}function Oi(e,t){return hi(e,{dir:"right",size:t})}function Jt(e){return e.length}function Ci(e,t={}){return xe(e,t)}function Ui(e){try{return Si(e),!0}catch{return!1}}class qe extends K{constructor(t){super(`Value \`${typeof t=="object"?Kt(t):t}\` of type \`${typeof t}\` is an invalid Bytes value.`,{metaMessages:["Bytes values must be of type `Bytes`."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Bytes.InvalidBytesTypeError"})}}class ki extends K{constructor({givenSize:t,maxSize:r}){super(`Size cannot exceed \`${r}\` bytes. Given size: \`${t}\` bytes.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Bytes.SizeOverflowError"})}}class Li extends K{constructor({size:t,targetSize:r,type:n}){super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (\`${t}\`) exceeds padding size (\`${r}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Bytes.SizeExceedsPaddingSizeError"})}}function Mr(e,t={}){const{as:r=typeof e=="string"?"Hex":"Bytes"}=t,n=ii(Rr(e));return r==="Bytes"?n:xe(n)}class Ni extends Map{constructor(t){super(),Object.defineProperty(this,"maxSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxSize=t}get(t){const r=super.get(t);return super.has(t)&&r!==void 0&&(this.delete(t),super.set(t,r)),r}set(t,r){if(super.set(t,r),this.maxSize&&this.size>this.maxSize){const n=this.keys().next().value;n&&this.delete(n)}return this}}const zi={checksum:new Ni(8192)},ot=zi.checksum;function qr(e,t={}){const{compressed:r}=t,{prefix:n,x:i,y:s}=e;if(r===!1||typeof i=="bigint"&&typeof s=="bigint"){if(n!==4)throw new Qt({prefix:n,cause:new Ti});return}if(r===!0||typeof i=="bigint"&&typeof s>"u"){if(n!==3&&n!==2)throw new Qt({prefix:n,cause:new _i});return}throw new Pi({publicKey:e})}function ji(e){const t=(()=>{if(mi(e))return Vr(e);if(Ui(e))return Ki(e);const{prefix:r,x:n,y:i}=e;return typeof n=="bigint"&&typeof i=="bigint"?{prefix:r??4,x:n,y:i}:{prefix:r,x:n}})();return qr(t),t}function Ki(e){return Vr(xe(e))}function Vr(e){if(e.length!==132&&e.length!==130&&e.length!==68)throw new Ri({publicKey:e});if(e.length===130){const n=BigInt(de(e,0,32)),i=BigInt(de(e,32,64));return{prefix:4,x:n,y:i}}if(e.length===132){const n=Number(de(e,0,1)),i=BigInt(de(e,1,33)),s=BigInt(de(e,33,65));return{prefix:n,x:i,y:s}}const t=Number(de(e,0,1)),r=BigInt(de(e,1,33));return{prefix:t,x:r}}function Fi(e,t={}){qr(e);const{prefix:r,x:n,y:i}=e,{includePrefix:s=!0}=t;return xi(s?st(r,{size:1}):"0x",st(n,{size:32}),typeof i=="bigint"?st(i,{size:32}):"0x")}class Pi extends K{constructor({publicKey:t}){super(`Value \`${Kt(t)}\` is not a valid public key.`,{metaMessages:["Public key must contain:","- an `x` and `prefix` value (compressed)","- an `x`, `y`, and `prefix` value (uncompressed)"]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"PublicKey.InvalidError"})}}class Qt extends K{constructor({prefix:t,cause:r}){super(`Prefix "${t}" is invalid.`,{cause:r}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"PublicKey.InvalidPrefixError"})}}class _i extends K{constructor(){super("Prefix must be 2 or 3 for compressed public keys."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"PublicKey.InvalidCompressedPrefixError"})}}class Ti extends K{constructor(){super("Prefix must be 4 for uncompressed public keys."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"PublicKey.InvalidUncompressedPrefixError"})}}class Ri extends K{constructor({publicKey:t}){super(`Value \`${t}\` is an invalid public key size.`,{metaMessages:["Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).",`Received ${ye(Pr(t))} bytes.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"PublicKey.InvalidSerializedSizeError"})}}const Mi=/^0x[a-fA-F0-9]{40}$/;function Dr(e,t={}){const{strict:r=!0}=t;if(!Mi.test(e))throw new er({address:e,cause:new Di});if(r){if(e.toLowerCase()===e)return;if(Ft(e)!==e)throw new er({address:e,cause:new Gi})}}function Ft(e){if(ot.has(e))return ot.get(e);Dr(e,{strict:!1});const t=e.substring(2).toLowerCase(),r=Mr($i(t),{as:"Bytes"}),n=t.split("");for(let s=0;s<40;s+=2)r[s>>1]>>4>=8&&n[s]&&(n[s]=n[s].toUpperCase()),(r[s>>1]&15)>=8&&n[s+1]&&(n[s+1]=n[s+1].toUpperCase());const i=`0x${n.join("")}`;return ot.set(e,i),i}function qi(e,t={}){const{checksum:r=!1}=t;return Dr(e),r?Ft(e):e}function Vi(e,t={}){const r=Mr(`0x${Fi(e).slice(4)}`).substring(26);return qi(`0x${r}`,t)}class er extends K{constructor({address:t,cause:r}){super(`Address "${t}" is invalid.`,{cause:r}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Address.InvalidAddressError"})}}class Di extends K{constructor(){super("Address is not a 20 byte (40 hexadecimal character) value."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Address.InvalidInputError"})}}class Gi extends K{constructor(){super("Address does not match its checksum counterpart."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Address.InvalidChecksumError"})}}const[Zi,Wi]=O.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(e=>BigInt(e))),ae=new Uint32Array(80),fe=new Uint32Array(80);class Yi extends Ot{constructor(t=64){super(128,t,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:t,Al:r,Bh:n,Bl:i,Ch:s,Cl:o,Dh:c,Dl:a,Eh:f,El:h,Fh:d,Fl:l,Gh:p,Gl:B,Hh:w,Hl:u}=this;return[t,r,n,i,s,o,c,a,f,h,d,l,p,B,w,u]}set(t,r,n,i,s,o,c,a,f,h,d,l,p,B,w,u){this.Ah=t|0,this.Al=r|0,this.Bh=n|0,this.Bl=i|0,this.Ch=s|0,this.Cl=o|0,this.Dh=c|0,this.Dl=a|0,this.Eh=f|0,this.El=h|0,this.Fh=d|0,this.Fl=l|0,this.Gh=p|0,this.Gl=B|0,this.Hh=w|0,this.Hl=u|0}process(t,r){for(let g=0;g<16;g++,r+=4)ae[g]=t.getUint32(r),fe[g]=t.getUint32(r+=4);for(let g=16;g<80;g++){const H=ae[g-15]|0,A=fe[g-15]|0,$=O.rotrSH(H,A,1)^O.rotrSH(H,A,8)^O.shrSH(H,A,7),S=O.rotrSL(H,A,1)^O.rotrSL(H,A,8)^O.shrSL(H,A,7),I=ae[g-2]|0,v=fe[g-2]|0,z=O.rotrSH(I,v,19)^O.rotrBH(I,v,61)^O.shrSH(I,v,6),N=O.rotrSL(I,v,19)^O.rotrBL(I,v,61)^O.shrSL(I,v,6),U=O.add4L(S,N,fe[g-7],fe[g-16]),T=O.add4H(U,$,z,ae[g-7],ae[g-16]);ae[g]=T|0,fe[g]=U|0}let{Ah:n,Al:i,Bh:s,Bl:o,Ch:c,Cl:a,Dh:f,Dl:h,Eh:d,El:l,Fh:p,Fl:B,Gh:w,Gl:u,Hh:b,Hl:E}=this;for(let g=0;g<80;g++){const H=O.rotrSH(d,l,14)^O.rotrSH(d,l,18)^O.rotrBH(d,l,41),A=O.rotrSL(d,l,14)^O.rotrSL(d,l,18)^O.rotrBL(d,l,41),$=d&p^~d&w,S=l&B^~l&u,I=O.add5L(E,A,S,Wi[g],fe[g]),v=O.add5H(I,b,H,$,Zi[g],ae[g]),z=I|0,N=O.rotrSH(n,i,28)^O.rotrBH(n,i,34)^O.rotrBH(n,i,39),U=O.rotrSL(n,i,28)^O.rotrBL(n,i,34)^O.rotrBL(n,i,39),T=n&s^n&c^s&c,x=i&o^i&a^o&a;b=w|0,E=u|0,w=p|0,u=B|0,p=d|0,B=l|0,{h:d,l}=O.add(f|0,h|0,v|0,z|0),f=c|0,h=a|0,c=s|0,a=o|0,s=n|0,o=i|0;const y=O.add3L(z,U,x);n=O.add3H(y,v,N,T),i=y|0}({h:n,l:i}=O.add(this.Ah|0,this.Al|0,n|0,i|0)),{h:s,l:o}=O.add(this.Bh|0,this.Bl|0,s|0,o|0),{h:c,l:a}=O.add(this.Ch|0,this.Cl|0,c|0,a|0),{h:f,l:h}=O.add(this.Dh|0,this.Dl|0,f|0,h|0),{h:d,l}=O.add(this.Eh|0,this.El|0,d|0,l|0),{h:p,l:B}=O.add(this.Fh|0,this.Fl|0,p|0,B|0),{h:w,l:u}=O.add(this.Gh|0,this.Gl|0,w|0,u|0),{h:b,l:E}=O.add(this.Hh|0,this.Hl|0,b|0,E|0),this.set(n,i,s,o,c,a,f,h,d,l,p,B,w,u,b,E)}roundClean(){ae.fill(0),fe.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const xt=Je(()=>new Yi);class Gr extends $t{constructor(t,r){super(),this.finished=!1,this.destroyed=!1,xr(t);const n=$e(r);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,s=new Uint8Array(i);s.set(n.length>i?t.create().update(n).digest():n);for(let o=0;o<s.length;o++)s[o]^=54;this.iHash.update(s),this.oHash=t.create();for(let o=0;o<s.length;o++)s[o]^=106;this.oHash.update(s),s.fill(0)}update(t){return He(this),this.iHash.update(t),this}digestInto(t){He(this),G(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:r,iHash:n,finished:i,destroyed:s,blockLen:o,outputLen:c}=this;return t=t,t.finished=i,t.destroyed=s,t.blockLen=o,t.outputLen=c,t.oHash=r._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Fe=(e,t,r)=>new Gr(e,t).update(r).digest();Fe.create=(e,t)=>new Gr(e,t);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _=BigInt(0),j=BigInt(1),he=BigInt(2),Xi=BigInt(3),yt=BigInt(4),tr=BigInt(5),rr=BigInt(8);function M(e,t){const r=e%t;return r>=_?r:t+r}function Ji(e,t,r){if(t<_)throw new Error("invalid exponent, negatives unsupported");if(r<=_)throw new Error("invalid modulus");if(r===j)return _;let n=j;for(;t>_;)t&j&&(n=n*e%r),e=e*e%r,t>>=j;return n}function D(e,t,r){let n=e;for(;t-- >_;)n*=n,n%=r;return n}function mt(e,t){if(e===_)throw new Error("invert: expected non-zero number");if(t<=_)throw new Error("invert: expected positive modulus, got "+t);let r=M(e,t),n=t,i=_,s=j;for(;r!==_;){const c=n/r,a=n%r,f=i-s*c;n=r,r=a,i=s,s=f}if(n!==j)throw new Error("invert: does not exist");return M(i,t)}function Qi(e){const t=(e-j)/he;let r,n,i;for(r=e-j,n=0;r%he===_;r/=he,n++);for(i=he;i<e&&Ji(i,t,e)!==e-j;i++)if(i>1e3)throw new Error("Cannot find square root: likely non-prime P");if(n===1){const o=(e+j)/yt;return function(a,f){const h=a.pow(f,o);if(!a.eql(a.sqr(h),f))throw new Error("Cannot find square root");return h}}const s=(r+j)/he;return function(c,a){if(c.pow(a,t)===c.neg(c.ONE))throw new Error("Cannot find square root");let f=n,h=c.pow(c.mul(c.ONE,i),r),d=c.pow(a,s),l=c.pow(a,r);for(;!c.eql(l,c.ONE);){if(c.eql(l,c.ZERO))return c.ZERO;let p=1;for(let w=c.sqr(l);p<f&&!c.eql(w,c.ONE);p++)w=c.sqr(w);const B=c.pow(h,j<<BigInt(f-p-1));h=c.sqr(B),d=c.mul(d,B),l=c.mul(l,h),f=p}return d}}function es(e){if(e%yt===Xi){const t=(e+j)/yt;return function(n,i){const s=n.pow(i,t);if(!n.eql(n.sqr(s),i))throw new Error("Cannot find square root");return s}}if(e%rr===tr){const t=(e-tr)/rr;return function(n,i){const s=n.mul(i,he),o=n.pow(s,t),c=n.mul(i,o),a=n.mul(n.mul(c,he),o),f=n.mul(c,n.sub(a,n.ONE));if(!n.eql(n.sqr(f),i))throw new Error("Cannot find square root");return f}}return Qi(e)}const ts=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function rs(e){const t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},r=ts.reduce((n,i)=>(n[i]="function",n),t);return et(e,r)}function ns(e,t,r){if(r<_)throw new Error("invalid exponent, negatives unsupported");if(r===_)return e.ONE;if(r===j)return t;let n=e.ONE,i=t;for(;r>_;)r&j&&(n=e.mul(n,i)),i=e.sqr(i),r>>=j;return n}function is(e,t){const r=new Array(t.length),n=t.reduce((s,o,c)=>e.is0(o)?s:(r[c]=s,e.mul(s,o)),e.ONE),i=e.inv(n);return t.reduceRight((s,o,c)=>e.is0(o)?s:(r[c]=e.mul(s,r[c]),e.mul(s,o)),i),r}function Zr(e,t){const r=t!==void 0?t:e.toString(2).length,n=Math.ceil(r/8);return{nBitLength:r,nByteLength:n}}function Wr(e,t,r=!1,n={}){if(e<=_)throw new Error("invalid field: expected ORDER > 0, got "+e);const{nBitLength:i,nByteLength:s}=Zr(e,t);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let o;const c=Object.freeze({ORDER:e,isLE:r,BITS:i,BYTES:s,MASK:Qe(i),ZERO:_,ONE:j,create:a=>M(a,e),isValid:a=>{if(typeof a!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof a);return _<=a&&a<e},is0:a=>a===_,isOdd:a=>(a&j)===j,neg:a=>M(-a,e),eql:(a,f)=>a===f,sqr:a=>M(a*a,e),add:(a,f)=>M(a+f,e),sub:(a,f)=>M(a-f,e),mul:(a,f)=>M(a*f,e),pow:(a,f)=>ns(c,a,f),div:(a,f)=>M(a*mt(f,e),e),sqrN:a=>a*a,addN:(a,f)=>a+f,subN:(a,f)=>a-f,mulN:(a,f)=>a*f,inv:a=>mt(a,e),sqrt:n.sqrt||(a=>(o||(o=es(e)),o(c,a))),invertBatch:a=>is(c,a),cmov:(a,f,h)=>h?f:a,toBytes:a=>r?jr(a,s):Ke(a,s),fromBytes:a=>{if(a.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+a.length);return r?zr(a):we(a)}});return Object.freeze(c)}function Yr(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function Xr(e){const t=Yr(e);return t+Math.ceil(t/2)}function ss(e,t,r=!1){const n=e.length,i=Yr(t),s=Xr(t);if(n<16||n<s||n>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+n);const o=r?zr(e):we(e),c=M(o,t-j)+j;return r?jr(c,i):Ke(c,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const nr=BigInt(0),Et=BigInt(1);function ct(e,t){const r=t.negate();return e?r:t}function Jr(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+e)}function at(e,t){Jr(e,t);const r=Math.ceil(t/e)+1,n=2**(e-1),i=2**e,s=Qe(e),o=BigInt(e);return{windows:r,windowSize:n,mask:s,maxNumber:i,shiftBy:o}}function ir(e,t,r){const{windowSize:n,mask:i,maxNumber:s,shiftBy:o}=r;let c=Number(e&i),a=e>>o;c>n&&(c-=s,a+=Et);const f=t*n,h=f+Math.abs(c)-1,d=c===0,l=c<0,p=t%2!==0;return{nextN:a,offset:h,isZero:d,isNeg:l,isNegF:p,offsetF:f}}function os(e,t){if(!Array.isArray(e))throw new Error("array expected");e.forEach((r,n)=>{if(!(r instanceof t))throw new Error("invalid point at index "+n)})}function cs(e,t){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((r,n)=>{if(!t.isValid(r))throw new Error("invalid scalar at index "+n)})}const ft=new WeakMap,Qr=new WeakMap;function ut(e){return Qr.get(e)||1}function as(e,t){return{constTimeNegate:ct,hasPrecomputes(r){return ut(r)!==1},unsafeLadder(r,n,i=e.ZERO){let s=r;for(;n>nr;)n&Et&&(i=i.add(s)),s=s.double(),n>>=Et;return i},precomputeWindow(r,n){const{windows:i,windowSize:s}=at(n,t),o=[];let c=r,a=c;for(let f=0;f<i;f++){a=c,o.push(a);for(let h=1;h<s;h++)a=a.add(c),o.push(a);c=a.double()}return o},wNAF(r,n,i){let s=e.ZERO,o=e.BASE;const c=at(r,t);for(let a=0;a<c.windows;a++){const{nextN:f,offset:h,isZero:d,isNeg:l,isNegF:p,offsetF:B}=ir(i,a,c);i=f,d?o=o.add(ct(p,n[B])):s=s.add(ct(l,n[h]))}return{p:s,f:o}},wNAFUnsafe(r,n,i,s=e.ZERO){const o=at(r,t);for(let c=0;c<o.windows&&i!==nr;c++){const{nextN:a,offset:f,isZero:h,isNeg:d}=ir(i,c,o);if(i=a,!h){const l=n[f];s=s.add(d?l.negate():l)}}return s},getPrecomputes(r,n,i){let s=ft.get(n);return s||(s=this.precomputeWindow(n,r),r!==1&&ft.set(n,i(s))),s},wNAFCached(r,n,i){const s=ut(r);return this.wNAF(s,this.getPrecomputes(s,r,i),n)},wNAFCachedUnsafe(r,n,i,s){const o=ut(r);return o===1?this.unsafeLadder(r,n,s):this.wNAFUnsafe(o,this.getPrecomputes(o,r,i),n,s)},setWindowSize(r,n){Jr(n,t),Qr.set(r,n),ft.delete(r)}}}function fs(e,t,r,n){if(os(r,e),cs(n,t),r.length!==n.length)throw new Error("arrays of points and scalars must have equal length");const i=e.ZERO,s=ai(BigInt(r.length)),o=s>12?s-3:s>4?s-2:s?2:1,c=Qe(o),a=new Array(Number(c)+1).fill(i),f=Math.floor((t.BITS-1)/o)*o;let h=i;for(let d=f;d>=0;d-=o){a.fill(i);for(let p=0;p<n.length;p++){const B=n[p],w=Number(B>>BigInt(d)&c);a[w]=a[w].add(r[p])}let l=i;for(let p=a.length-1,B=i;p>0;p--)B=B.add(a[p]),l=l.add(B);if(h=h.add(l),d!==0)for(let p=0;p<o;p++)h=h.double()}return h}function en(e){return rs(e.Fp),et(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Zr(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function sr(e){e.lowS!==void 0&&ze("lowS",e.lowS),e.prehash!==void 0&&ze("prehash",e.prehash)}function us(e){const t=en(e);et(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:n,a:i}=t;if(r){if(!n.eql(i,n.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof r!="object"||typeof r.beta!="bigint"||typeof r.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...t})}class ls extends Error{constructor(t=""){super(t)}}const ne={Err:ls,_tlv:{encode:(e,t)=>{const{Err:r}=ne;if(e<0||e>256)throw new r("tlv.encode: wrong tag");if(t.length&1)throw new r("tlv.encode: unpadded data");const n=t.length/2,i=Me(n);if(i.length/2&128)throw new r("tlv.encode: long form length too big");const s=n>127?Me(i.length/2|128):"";return Me(e)+s+i+t},decode(e,t){const{Err:r}=ne;let n=0;if(e<0||e>256)throw new r("tlv.encode: wrong tag");if(t.length<2||t[n++]!==e)throw new r("tlv.decode: wrong tlv");const i=t[n++],s=!!(i&128);let o=0;if(!s)o=i;else{const a=i&127;if(!a)throw new r("tlv.decode(long): indefinite length not supported");if(a>4)throw new r("tlv.decode(long): byte length is too big");const f=t.subarray(n,n+a);if(f.length!==a)throw new r("tlv.decode: length bytes not complete");if(f[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(const h of f)o=o<<8|h;if(n+=a,o<128)throw new r("tlv.decode(long): not minimal encoding")}const c=t.subarray(n,n+o);if(c.length!==o)throw new r("tlv.decode: wrong value length");return{v:c,l:t.subarray(n+o)}}},_int:{encode(e){const{Err:t}=ne;if(e<ie)throw new t("integer: negative integers are not allowed");let r=Me(e);if(Number.parseInt(r[0],16)&8&&(r="00"+r),r.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return r},decode(e){const{Err:t}=ne;if(e[0]&128)throw new t("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return we(e)}},toSig(e){const{Err:t,_int:r,_tlv:n}=ne,i=W("signature",e),{v:s,l:o}=n.decode(48,i);if(o.length)throw new t("invalid signature: left bytes after parsing");const{v:c,l:a}=n.decode(2,s),{v:f,l:h}=n.decode(2,a);if(h.length)throw new t("invalid signature: left bytes after parsing");return{r:r.decode(c),s:r.decode(f)}},hexFromSig(e){const{_tlv:t,_int:r}=ne,n=t.encode(2,r.encode(e.r)),i=t.encode(2,r.encode(e.s)),s=n+i;return t.encode(48,s)}},ie=BigInt(0),P=BigInt(1);BigInt(2);const or=BigInt(3);BigInt(4);function ds(e){const t=us(e),{Fp:r}=t,n=Wr(t.n,t.nBitLength),i=t.toBytes||((w,u,b)=>{const E=u.toAffine();return Ye(Uint8Array.from([4]),r.toBytes(E.x),r.toBytes(E.y))}),s=t.fromBytes||(w=>{const u=w.subarray(1),b=r.fromBytes(u.subarray(0,r.BYTES)),E=r.fromBytes(u.subarray(r.BYTES,2*r.BYTES));return{x:b,y:E}});function o(w){const{a:u,b}=t,E=r.sqr(w),g=r.mul(E,w);return r.add(r.add(g,r.mul(w,u)),b)}if(!r.eql(r.sqr(t.Gy),o(t.Gx)))throw new Error("bad generator point: equation left != right");function c(w){return jt(w,P,t.n)}function a(w){const{allowedPrivateKeyLengths:u,nByteLength:b,wrapPrivateKey:E,n:g}=t;if(u&&typeof w!="bigint"){if(Oe(w)&&(w=je(w)),typeof w!="string"||!u.includes(w.length))throw new Error("invalid private key");w=w.padStart(b*2,"0")}let H;try{H=typeof w=="bigint"?w:we(W("private key",w,b))}catch{throw new Error("invalid private key, expected hex or "+b+" bytes, got "+typeof w)}return E&&(H=M(H,g)),Se("private key",H,P,g),H}function f(w){if(!(w instanceof l))throw new Error("ProjectivePoint expected")}const h=Zt((w,u)=>{const{px:b,py:E,pz:g}=w;if(r.eql(g,r.ONE))return{x:b,y:E};const H=w.is0();u==null&&(u=H?r.ONE:r.inv(g));const A=r.mul(b,u),$=r.mul(E,u),S=r.mul(g,u);if(H)return{x:r.ZERO,y:r.ZERO};if(!r.eql(S,r.ONE))throw new Error("invZ was invalid");return{x:A,y:$}}),d=Zt(w=>{if(w.is0()){if(t.allowInfinityPoint&&!r.is0(w.py))return;throw new Error("bad point: ZERO")}const{x:u,y:b}=w.toAffine();if(!r.isValid(u)||!r.isValid(b))throw new Error("bad point: x or y not FE");const E=r.sqr(b),g=o(u);if(!r.eql(E,g))throw new Error("bad point: equation left != right");if(!w.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class l{constructor(u,b,E){if(u==null||!r.isValid(u))throw new Error("x required");if(b==null||!r.isValid(b))throw new Error("y required");if(E==null||!r.isValid(E))throw new Error("z required");this.px=u,this.py=b,this.pz=E,Object.freeze(this)}static fromAffine(u){const{x:b,y:E}=u||{};if(!u||!r.isValid(b)||!r.isValid(E))throw new Error("invalid affine point");if(u instanceof l)throw new Error("projective point not allowed");const g=H=>r.eql(H,r.ZERO);return g(b)&&g(E)?l.ZERO:new l(b,E,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){const b=r.invertBatch(u.map(E=>E.pz));return u.map((E,g)=>E.toAffine(b[g])).map(l.fromAffine)}static fromHex(u){const b=l.fromAffine(s(W("pointHex",u)));return b.assertValidity(),b}static fromPrivateKey(u){return l.BASE.multiply(a(u))}static msm(u,b){return fs(l,n,u,b)}_setWindowSize(u){B.setWindowSize(this,u)}assertValidity(){d(this)}hasEvenY(){const{y:u}=this.toAffine();if(r.isOdd)return!r.isOdd(u);throw new Error("Field doesn't support isOdd")}equals(u){f(u);const{px:b,py:E,pz:g}=this,{px:H,py:A,pz:$}=u,S=r.eql(r.mul(b,$),r.mul(H,g)),I=r.eql(r.mul(E,$),r.mul(A,g));return S&&I}negate(){return new l(this.px,r.neg(this.py),this.pz)}double(){const{a:u,b}=t,E=r.mul(b,or),{px:g,py:H,pz:A}=this;let $=r.ZERO,S=r.ZERO,I=r.ZERO,v=r.mul(g,g),z=r.mul(H,H),N=r.mul(A,A),U=r.mul(g,H);return U=r.add(U,U),I=r.mul(g,A),I=r.add(I,I),$=r.mul(u,I),S=r.mul(E,N),S=r.add($,S),$=r.sub(z,S),S=r.add(z,S),S=r.mul($,S),$=r.mul(U,$),I=r.mul(E,I),N=r.mul(u,N),U=r.sub(v,N),U=r.mul(u,U),U=r.add(U,I),I=r.add(v,v),v=r.add(I,v),v=r.add(v,N),v=r.mul(v,U),S=r.add(S,v),N=r.mul(H,A),N=r.add(N,N),v=r.mul(N,U),$=r.sub($,v),I=r.mul(N,z),I=r.add(I,I),I=r.add(I,I),new l($,S,I)}add(u){f(u);const{px:b,py:E,pz:g}=this,{px:H,py:A,pz:$}=u;let S=r.ZERO,I=r.ZERO,v=r.ZERO;const z=t.a,N=r.mul(t.b,or);let U=r.mul(b,H),T=r.mul(E,A),x=r.mul(g,$),y=r.add(b,E),m=r.add(H,A);y=r.mul(y,m),m=r.add(U,T),y=r.sub(y,m),m=r.add(b,g);let C=r.add(H,$);return m=r.mul(m,C),C=r.add(U,x),m=r.sub(m,C),C=r.add(E,g),S=r.add(A,$),C=r.mul(C,S),S=r.add(T,x),C=r.sub(C,S),v=r.mul(z,m),S=r.mul(N,x),v=r.add(S,v),S=r.sub(T,v),v=r.add(T,v),I=r.mul(S,v),T=r.add(U,U),T=r.add(T,U),x=r.mul(z,x),m=r.mul(N,m),T=r.add(T,x),x=r.sub(U,x),x=r.mul(z,x),m=r.add(m,x),U=r.mul(T,m),I=r.add(I,U),U=r.mul(C,m),S=r.mul(y,S),S=r.sub(S,U),U=r.mul(y,T),v=r.mul(C,v),v=r.add(v,U),new l(S,I,v)}subtract(u){return this.add(u.negate())}is0(){return this.equals(l.ZERO)}wNAF(u){return B.wNAFCached(this,u,l.normalizeZ)}multiplyUnsafe(u){const{endo:b,n:E}=t;Se("scalar",u,ie,E);const g=l.ZERO;if(u===ie)return g;if(this.is0()||u===P)return this;if(!b||B.hasPrecomputes(this))return B.wNAFCachedUnsafe(this,u,l.normalizeZ);let{k1neg:H,k1:A,k2neg:$,k2:S}=b.splitScalar(u),I=g,v=g,z=this;for(;A>ie||S>ie;)A&P&&(I=I.add(z)),S&P&&(v=v.add(z)),z=z.double(),A>>=P,S>>=P;return H&&(I=I.negate()),$&&(v=v.negate()),v=new l(r.mul(v.px,b.beta),v.py,v.pz),I.add(v)}multiply(u){const{endo:b,n:E}=t;Se("scalar",u,P,E);let g,H;if(b){const{k1neg:A,k1:$,k2neg:S,k2:I}=b.splitScalar(u);let{p:v,f:z}=this.wNAF($),{p:N,f:U}=this.wNAF(I);v=B.constTimeNegate(A,v),N=B.constTimeNegate(S,N),N=new l(r.mul(N.px,b.beta),N.py,N.pz),g=v.add(N),H=z.add(U)}else{const{p:A,f:$}=this.wNAF(u);g=A,H=$}return l.normalizeZ([g,H])[0]}multiplyAndAddUnsafe(u,b,E){const g=l.BASE,H=($,S)=>S===ie||S===P||!$.equals(g)?$.multiplyUnsafe(S):$.multiply(S),A=H(this,b).add(H(u,E));return A.is0()?void 0:A}toAffine(u){return h(this,u)}isTorsionFree(){const{h:u,isTorsionFree:b}=t;if(u===P)return!0;if(b)return b(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:u,clearCofactor:b}=t;return u===P?this:b?b(l,this):this.multiplyUnsafe(t.h)}toRawBytes(u=!0){return ze("isCompressed",u),this.assertValidity(),i(l,this,u)}toHex(u=!0){return ze("isCompressed",u),je(this.toRawBytes(u))}}l.BASE=new l(t.Gx,t.Gy,r.ONE),l.ZERO=new l(r.ZERO,r.ONE,r.ZERO);const p=t.nBitLength,B=as(l,t.endo?Math.ceil(p/2):p);return{CURVE:t,ProjectivePoint:l,normPrivateKeyToScalar:a,weierstrassEquation:o,isWithinCurveOrder:c}}function hs(e){const t=en(e);return et(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function ps(e){const t=hs(e),{Fp:r,n}=t,i=r.BYTES+1,s=2*r.BYTES+1;function o(x){return M(x,n)}function c(x){return mt(x,n)}const{ProjectivePoint:a,normPrivateKeyToScalar:f,weierstrassEquation:h,isWithinCurveOrder:d}=ds({...t,toBytes(x,y,m){const C=y.toAffine(),k=r.toBytes(C.x),F=Ye;return ze("isCompressed",m),m?F(Uint8Array.from([y.hasEvenY()?2:3]),k):F(Uint8Array.from([4]),k,r.toBytes(C.y))},fromBytes(x){const y=x.length,m=x[0],C=x.subarray(1);if(y===i&&(m===2||m===3)){const k=we(C);if(!jt(k,P,r.ORDER))throw new Error("Point is not on curve");const F=h(k);let q;try{q=r.sqrt(F)}catch(Z){const V=Z instanceof Error?": "+Z.message:"";throw new Error("Point is not on curve"+V)}const R=(q&P)===P;return(m&1)===1!==R&&(q=r.neg(q)),{x:k,y:q}}else if(y===s&&m===4){const k=r.fromBytes(C.subarray(0,r.BYTES)),F=r.fromBytes(C.subarray(r.BYTES,2*r.BYTES));return{x:k,y:F}}else{const k=i,F=s;throw new Error("invalid Point, expected length of "+k+", or uncompressed "+F+", got "+y)}}}),l=x=>je(Ke(x,t.nByteLength));function p(x){const y=n>>P;return x>y}function B(x){return p(x)?o(-x):x}const w=(x,y,m)=>we(x.slice(y,m));class u{constructor(y,m,C){Se("r",y,P,n),Se("s",m,P,n),this.r=y,this.s=m,C!=null&&(this.recovery=C),Object.freeze(this)}static fromCompact(y){const m=t.nByteLength;return y=W("compactSignature",y,m*2),new u(w(y,0,m),w(y,m,2*m))}static fromDER(y){const{r:m,s:C}=ne.toSig(W("DER",y));return new u(m,C)}assertValidity(){}addRecoveryBit(y){return new u(this.r,this.s,y)}recoverPublicKey(y){const{r:m,s:C,recovery:k}=this,F=$(W("msgHash",y));if(k==null||![0,1,2,3].includes(k))throw new Error("recovery id invalid");const q=k===2||k===3?m+t.n:m;if(q>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const R=(k&1)===0?"02":"03",Q=a.fromHex(R+l(q)),Z=c(q),V=o(-F*Z),me=o(C*Z),se=a.BASE.multiplyAndAddUnsafe(Q,V,me);if(!se)throw new Error("point at infinify");return se.assertValidity(),se}hasHighS(){return p(this.s)}normalizeS(){return this.hasHighS()?new u(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return We(this.toDERHex())}toDERHex(){return ne.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return We(this.toCompactHex())}toCompactHex(){return l(this.r)+l(this.s)}}const b={isValidPrivateKey(x){try{return f(x),!0}catch{return!1}},normPrivateKeyToScalar:f,randomPrivateKey:()=>{const x=Xr(t.n);return ss(t.randomBytes(x),t.n)},precompute(x=8,y=a.BASE){return y._setWindowSize(x),y.multiply(BigInt(3)),y}};function E(x,y=!0){return a.fromPrivateKey(x).toRawBytes(y)}function g(x){const y=Oe(x),m=typeof x=="string",C=(y||m)&&x.length;return y?C===i||C===s:m?C===2*i||C===2*s:x instanceof a}function H(x,y,m=!0){if(g(x))throw new Error("first arg must be private key");if(!g(y))throw new Error("second arg must be public key");return a.fromHex(y).multiply(f(x)).toRawBytes(m)}const A=t.bits2int||function(x){if(x.length>8192)throw new Error("input is too large");const y=we(x),m=x.length*8-t.nBitLength;return m>0?y>>BigInt(m):y},$=t.bits2int_modN||function(x){return o(A(x))},S=Qe(t.nBitLength);function I(x){return Se("num < 2^"+t.nBitLength,x,ie,S),Ke(x,t.nByteLength)}function v(x,y,m=z){if(["recovered","canonical"].some(ue=>ue in m))throw new Error("sign() legacy options not supported");const{hash:C,randomBytes:k}=t;let{lowS:F,prehash:q,extraEntropy:R}=m;F==null&&(F=!0),x=W("msgHash",x),sr(m),q&&(x=W("prehashed msgHash",C(x)));const Q=$(x),Z=f(y),V=[I(Z),I(Q)];if(R!=null&&R!==!1){const ue=R===!0?k(r.BYTES):R;V.push(W("extraEntropy",ue))}const me=Ye(...V),se=Q;function tt(ue){const Ee=A(ue);if(!d(Ee))return;const rt=c(Ee),Ce=a.BASE.multiply(Ee).toAffine(),le=o(Ce.x);if(le===ie)return;const Ue=o(rt*o(se+le*Z));if(Ue===ie)return;let ke=(Ce.x===le?0:2)|Number(Ce.y&P),ve=Ue;return F&&p(Ue)&&(ve=B(Ue),ke^=1),new u(le,ve,ke)}return{seed:me,k2sig:tt}}const z={lowS:t.lowS,prehash:!1},N={lowS:t.lowS,prehash:!1};function U(x,y,m=z){const{seed:C,k2sig:k}=v(x,y,m),F=t;return fi(F.hash.outputLen,F.nByteLength,F.hmac)(C,k)}a.BASE._setWindowSize(8);function T(x,y,m,C=N){var ke;const k=x;y=W("msgHash",y),m=W("publicKey",m);const{lowS:F,prehash:q,format:R}=C;if(sr(C),"strict"in C)throw new Error("options.strict was renamed to lowS");if(R!==void 0&&R!=="compact"&&R!=="der")throw new Error("format must be compact or der");const Q=typeof k=="string"||Oe(k),Z=!Q&&!R&&typeof k=="object"&&k!==null&&typeof k.r=="bigint"&&typeof k.s=="bigint";if(!Q&&!Z)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let V,me;try{if(Z&&(V=new u(k.r,k.s)),Q){try{R!=="compact"&&(V=u.fromDER(k))}catch(ve){if(!(ve instanceof ne.Err))throw ve}!V&&R!=="der"&&(V=u.fromCompact(k))}me=a.fromHex(m)}catch{return!1}if(!V||F&&V.hasHighS())return!1;q&&(y=t.hash(y));const{r:se,s:tt}=V,ue=$(y),Ee=c(tt),rt=o(ue*Ee),Ce=o(se*Ee),le=(ke=a.BASE.multiplyAndAddUnsafe(me,rt,Ce))==null?void 0:ke.toAffine();return le?o(le.x)===se:!1}return{CURVE:t,getPublicKey:E,getSharedSecret:H,sign:U,verify:T,ProjectivePoint:a,Signature:u,utils:b}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function bs(e){return{hash:e,hmac:(t,...r)=>Fe(e,t,Ne(...r)),randomBytes:En}}function gs(e,t){const r=n=>ps({...e,...bs(n)});return{...r(t),create:r}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const tn=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),cr=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),ws=BigInt(1),vt=BigInt(2),ar=(e,t)=>(e+t/vt)/t;function xs(e){const t=tn,r=BigInt(3),n=BigInt(6),i=BigInt(11),s=BigInt(22),o=BigInt(23),c=BigInt(44),a=BigInt(88),f=e*e*e%t,h=f*f*e%t,d=D(h,r,t)*h%t,l=D(d,r,t)*h%t,p=D(l,vt,t)*f%t,B=D(p,i,t)*p%t,w=D(B,s,t)*B%t,u=D(w,c,t)*w%t,b=D(u,a,t)*u%t,E=D(b,c,t)*w%t,g=D(E,r,t)*h%t,H=D(g,o,t)*B%t,A=D(H,n,t)*f%t,$=D(A,vt,t);if(!Bt.eql(Bt.sqr($),e))throw new Error("Cannot find square root");return $}const Bt=Wr(tn,void 0,void 0,{sqrt:xs}),Y=gs({a:BigInt(0),b:BigInt(7),Fp:Bt,n:cr,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const t=cr,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-ws*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=r,o=BigInt("0x100000000000000000000000000000000"),c=ar(s*e,t),a=ar(-n*e,t);let f=M(e-c*r-a*i,t),h=M(-c*n-a*s,t);const d=f>o,l=h>o;if(d&&(f=t-f),l&&(h=t-h),f>o||h>o)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:d,k1:f,k2neg:l,k2:h}}}},Lt);BigInt(0);Y.ProjectivePoint;/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function At(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function rn(e,t){return Array.isArray(t)?t.length===0?!0:e?t.every(r=>typeof r=="string"):t.every(r=>Number.isSafeInteger(r)):!1}function ys(e){if(typeof e!="function")throw new Error("function expected");return!0}function St(e,t){if(typeof t!="string")throw new Error(`${e}: string expected`);return!0}function Pt(e){if(!Number.isSafeInteger(e))throw new Error(`invalid integer: ${e}`)}function It(e){if(!Array.isArray(e))throw new Error("array expected")}function nn(e,t){if(!rn(!0,t))throw new Error(`${e}: array of strings expected`)}function ms(e,t){if(!rn(!1,t))throw new Error(`${e}: array of numbers expected`)}function sn(...e){const t=s=>s,r=(s,o)=>c=>s(o(c)),n=e.map(s=>s.encode).reduceRight(r,t),i=e.map(s=>s.decode).reduce(r,t);return{encode:n,decode:i}}function Es(e){const t=typeof e=="string"?e.split(""):e,r=t.length;nn("alphabet",t);const n=new Map(t.map((i,s)=>[i,s]));return{encode:i=>(It(i),i.map(s=>{if(!Number.isSafeInteger(s)||s<0||s>=r)throw new Error(`alphabet.encode: digit index outside alphabet "${s}". Allowed: ${e}`);return t[s]})),decode:i=>(It(i),i.map(s=>{St("alphabet.decode",s);const o=n.get(s);if(o===void 0)throw new Error(`Unknown letter: "${s}". Allowed: ${e}`);return o}))}}function vs(e=""){return St("join",e),{encode:t=>(nn("join.decode",t),t.join(e)),decode:t=>(St("join.decode",t),t.split(e))}}function fr(e,t,r){if(t<2)throw new Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);if(r<2)throw new Error(`convertRadix: invalid to=${r}, base cannot be less than 2`);if(It(e),!e.length)return[];let n=0;const i=[],s=Array.from(e,c=>{if(Pt(c),c<0||c>=t)throw new Error(`invalid integer: ${c}`);return c}),o=s.length;for(;;){let c=0,a=!0;for(let f=n;f<o;f++){const h=s[f],d=t*c,l=d+h;if(!Number.isSafeInteger(l)||d/t!==c||l-h!==d)throw new Error("convertRadix: carry overflow");const p=l/r;c=l%r;const B=Math.floor(p);if(s[f]=B,!Number.isSafeInteger(B)||B*r+c!==l)throw new Error("convertRadix: carry overflow");if(a)B?a=!1:n=f;else continue}if(i.push(c),a)break}for(let c=0;c<e.length-1&&e[c]===0;c++)i.push(0);return i.reverse()}function Bs(e){Pt(e);const t=2**8;return{encode:r=>{if(!At(r))throw new Error("radix.encode input should be Uint8Array");return fr(Array.from(r),t,e)},decode:r=>(ms("radix.decode",r),Uint8Array.from(fr(r,e,t)))}}function As(e,t){return Pt(e),ys(t),{encode(r){if(!At(r))throw new Error("checksum.encode: input should be Uint8Array");const n=t(r).slice(0,e),i=new Uint8Array(r.length+e);return i.set(r),i.set(n,r.length),i},decode(r){if(!At(r))throw new Error("checksum.decode: input should be Uint8Array");const n=r.slice(0,-e),i=r.slice(-e),s=t(n).slice(0,e);for(let o=0;o<e;o++)if(s[o]!==i[o])throw new Error("Invalid checksum");return n}}}const Ss=e=>sn(Bs(58),Es(e),vs("")),Is=Ss("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),Hs=e=>sn(As(4,t=>e(e(t))),Is);/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */const Ve=Y.ProjectivePoint,lt=Hs(Lt);function ur(e){G(e);const t=e.length===0?"0":xn(e);return BigInt("0x"+t)}function $s(e){if(typeof e!="bigint")throw new Error("bigint expected");return yn(e.toString(16).padStart(64,"0"))}const Os=Er("Bitcoin seed"),dt={private:76066276,public:76067358},ht=2147483648,Cs=e=>kn(Lt(e)),Us=e=>ge(e).getUint32(0,!1),De=e=>{if(!Number.isSafeInteger(e)||e<0||e>2**32-1)throw new Error("invalid number, should be from 0 to 2**32-1, got "+e);const t=new Uint8Array(4);return ge(t).setUint32(0,e,!1),t};class pe{get fingerprint(){if(!this.pubHash)throw new Error("No publicKey set!");return Us(this.pubHash)}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this.privKeyBytes||null}get publicKey(){return this.pubKey||null}get privateExtendedKey(){const t=this.privateKey;if(!t)throw new Error("No private key");return lt.encode(this.serialize(this.versions.private,Ne(new Uint8Array([0]),t)))}get publicExtendedKey(){if(!this.pubKey)throw new Error("No public key");return lt.encode(this.serialize(this.versions.public,this.pubKey))}static fromMasterSeed(t,r=dt){if(G(t),8*t.length<128||8*t.length>512)throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got "+t.length);const n=Fe(xt,Os,t);return new pe({versions:r,chainCode:n.slice(32),privateKey:n.slice(0,32)})}static fromExtendedKey(t,r=dt){const n=lt.decode(t),i=ge(n),s=i.getUint32(0,!1),o={versions:r,depth:n[4],parentFingerprint:i.getUint32(5,!1),index:i.getUint32(9,!1),chainCode:n.slice(13,45)},c=n.slice(45),a=c[0]===0;if(s!==r[a?"private":"public"])throw new Error("Version mismatch");return a?new pe({...o,privateKey:c.slice(1)}):new pe({...o,publicKey:c})}static fromJSON(t){return pe.fromExtendedKey(t.xpriv)}constructor(t){if(this.depth=0,this.index=0,this.chainCode=null,this.parentFingerprint=0,!t||typeof t!="object")throw new Error("HDKey.constructor must not be called directly");if(this.versions=t.versions||dt,this.depth=t.depth||0,this.chainCode=t.chainCode||null,this.index=t.index||0,this.parentFingerprint=t.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");if(t.publicKey&&t.privateKey)throw new Error("HDKey: publicKey and privateKey at same time.");if(t.privateKey){if(!Y.utils.isValidPrivateKey(t.privateKey))throw new Error("Invalid private key");this.privKey=typeof t.privateKey=="bigint"?t.privateKey:ur(t.privateKey),this.privKeyBytes=$s(this.privKey),this.pubKey=Y.getPublicKey(t.privateKey,!0)}else if(t.publicKey)this.pubKey=Ve.fromHex(t.publicKey).toRawBytes(!0);else throw new Error("HDKey: no public or private key provided");this.pubHash=Cs(this.pubKey)}derive(t){if(!/^[mM]'?/.test(t))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(t))return this;const r=t.replace(/^[mM]'?\//,"").split("/");let n=this;for(const i of r){const s=/^(\d+)('?)$/.exec(i),o=s&&s[1];if(!s||s.length!==3||typeof o!="string")throw new Error("invalid child index: "+i);let c=+o;if(!Number.isSafeInteger(c)||c>=ht)throw new Error("Invalid index");s[2]==="'"&&(c+=ht),n=n.deriveChild(c)}return n}deriveChild(t){if(!this.pubKey||!this.chainCode)throw new Error("No publicKey or chainCode set");let r=De(t);if(t>=ht){const c=this.privateKey;if(!c)throw new Error("Could not derive hardened child key");r=Ne(new Uint8Array([0]),c,r)}else r=Ne(this.pubKey,r);const n=Fe(xt,this.chainCode,r),i=ur(n.slice(0,32)),s=n.slice(32);if(!Y.utils.isValidPrivateKey(i))throw new Error("Tweak bigger than curve order");const o={versions:this.versions,chainCode:s,depth:this.depth+1,parentFingerprint:this.fingerprint,index:t};try{if(this.privateKey){const c=M(this.privKey+i,Y.CURVE.n);if(!Y.utils.isValidPrivateKey(c))throw new Error("The tweak was out of range or the resulted private key is invalid");o.privateKey=c}else{const c=Ve.fromHex(this.pubKey).add(Ve.fromPrivateKey(i));if(c.equals(Ve.ZERO))throw new Error("The tweak was equal to negative P, which made the result key invalid");o.publicKey=c.toRawBytes(!0)}return new pe(o)}catch{return this.deriveChild(t+1)}}sign(t){if(!this.privateKey)throw new Error("No privateKey set!");return G(t,32),Y.sign(t,this.privKey).toCompactRawBytes()}verify(t,r){if(G(t,32),G(r,64),!this.publicKey)throw new Error("No publicKey set!");let n;try{n=Y.Signature.fromCompact(r)}catch{return!1}return Y.verify(n,t,this.publicKey)}wipePrivateData(){return this.privKey=void 0,this.privKeyBytes&&(this.privKeyBytes.fill(0),this.privKeyBytes=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(t,r){if(!this.chainCode)throw new Error("No chainCode set");return G(r,33),Ne(De(t),new Uint8Array([this.depth]),De(this.parentFingerprint),De(this.index),this.chainCode,r)}}function ks(e){const{privateKey:t}=e,r=Y.ProjectivePoint.fromPrivateKey(Pr(t).slice(2));return ji(r)}function on(e){return{derive:t=>on(e.derive(t)),depth:e.depth,identifier:xe(e.identifier),index:e.index,privateKey:xe(e.privateKey),privateExtendedKey:e.privateExtendedKey,publicKey:ks({privateKey:e.privateKey}),publicExtendedKey:e.publicExtendedKey,versions:e.versions}}function Ls(e,t={}){const{versions:r}=t,n=pe.fromMasterSeed(Rr(e),r);return on(n)}function Ns(e={}){const{account:t=0,change:r=0,index:n=0}=e;return`m/44'/60'/${t}'/${r}/${n}`}function zs(e,t,r,n){xr(e);const i=mn({dkLen:32,asyncTick:10},n),{c:s,dkLen:o,asyncTick:c}=i;if(be(s),be(o),be(c),s<1)throw new Error("PBKDF2: iterations (c) should be >= 1");const a=$e(t),f=$e(r),h=new Uint8Array(o),d=Fe.create(e,a),l=d._cloneInto().update(f);return{c:s,dkLen:o,asyncTick:c,DK:h,PRF:d,PRFSalt:l}}function js(e,t,r,n,i){return e.destroy(),t.destroy(),n&&n.destroy(),i.fill(0),r}function Ks(e,t,r,n){const{c:i,dkLen:s,DK:o,PRF:c,PRFSalt:a}=zs(e,t,r,n);let f;const h=new Uint8Array(4),d=ge(h),l=new Uint8Array(c.outputLen);for(let p=1,B=0;B<s;p++,B+=c.outputLen){const w=o.subarray(B,B+c.outputLen);d.setInt32(0,p,!1),(f=a._cloneInto(f)).update(h).digestInto(l),w.set(l.subarray(0,w.length));for(let u=1;u<i;u++){c._cloneInto(f).update(l).digestInto(l);for(let b=0;b<w.length;b++)w[b]^=l[b]}}return js(c,a,o,f,l)}/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */function cn(e){if(typeof e!="string")throw new TypeError("invalid mnemonic type: "+typeof e);return e.normalize("NFKD")}function Fs(e){const t=cn(e),r=t.split(" ");if(![12,15,18,21,24].includes(r.length))throw new Error("Invalid mnemonic");return{nfkd:t,words:r}}const Ps=e=>cn("mnemonic"+e);function _s(e,t=""){return Ks(xt,Fs(e).nfkd,Ps(t),{c:2048,dkLen:64})}function Ts(e,t={}){const{passphrase:r}=t,n=Rs(e,{passphrase:r});return Ls(n)}function Rs(e,t={}){const{passphrase:r}=t,n=_s(e,r);return t.as==="Hex"?Ci(n):n}const Ht=1e3,Ie=64,pt=Ie/2,J="gradient-avatar-",Ms=un(["shrink-0 rounded-full overflow-hidden"],{variants:{size:{xs:"w-3 h-3",sm:"w-5 h-5",md:"w-8 h-8",lg:"w-10 h-10",xl:"w-[52px] h-[52px]"}},defaultVariants:{size:"md"}}),bt=(e,t=Ht)=>e%t/(Ht/Ie),Ae=(e,t=0)=>{let r=3735928559^t,n=1103547991^t;for(let i=0,s;i<e.length;i++)s=e.charCodeAt(i),r=Math.imul(r^s,2654435761),n=Math.imul(n^s,1597334677);return r=Math.imul(r^r>>>16,2246822507)^Math.imul(n^n>>>13,3266489909),n=Math.imul(n^n>>>16,2246822507)^Math.imul(r^r>>>13,3266489909),4294967296*(2097151&n)+(r>>>0)},qs=(e,t,r)=>{const n=e%360,i=(e+120)%360,s=r%360;return{a:`hsl(${n}deg 100% 40%)`,b:`hsl(${i}deg 100% 50%)`,c:`hsl(${s}deg 100% 50%)`}},Vs=(e,t)=>{const r=[];for(let n=0;n<t;n++){const i=n*6;r.push({a:Ae(e+"a",i),b:Ae(e+"b",i+1),c:Ae(e+"c",i+2),x:Ae(e+"d",i+3),y:Ae(e+"e",i+4),r:Ae(e+"f",i+5)})}return r.map((n,i)=>{const s=Ie/10+bt(n.r,Ht*1.5/(i+1));return{...qs(n.a,n.b,n.c),x:bt(n.x),y:bt(n.y),r:s}})},Xe=Pe.memo(e=>{const{className:t,address:r,size:n="md",complexity:i=1,...s}=e,o=Vs(r,i),c=Pe.useId();return L.jsxs("svg",{className:ln(Ms({size:n}),t),viewBox:`0 0 ${Ie} ${Ie}`,version:"1.1",xmlns:"http://www.w3.org/2000/svg",...s,children:[L.jsxs("defs",{children:[L.jsx("clipPath",{id:`${J}circle-clip${c}`,children:L.jsx("circle",{cx:pt,cy:pt,r:pt})}),L.jsxs("filter",{id:`${J}blur-xs${c}`,x:"-10%",y:"-10%",width:"120%",height:"120%",filterUnits:"userSpaceOnUse",colorInterpolationFilters:"sRGB",children:[L.jsx("feFlood",{floodOpacity:"0",result:"BackgroundImageFix"}),L.jsx("feBlend",{mode:"normal",in:"SourceGraphic",in2:"BackgroundImageFix",result:"shape"}),L.jsx("feGaussianBlur",{stdDeviation:Ie/10,result:"effect1_foregroundBlur"})]}),L.jsxs("linearGradient",{id:`${J}background${c}`,x1:"0",y1:"0",x2:"1",y2:"1",children:[L.jsx("stop",{offset:"0",stopColor:o[0].c}),L.jsx("stop",{offset:"1",stopColor:o[0].a})]}),o.map((a,f)=>L.jsxs(Pe.Fragment,{children:[L.jsxs("radialGradient",{id:`${J}primary${c}${f}`,children:[L.jsx("stop",{offset:"0",stopColor:a.a}),L.jsx("stop",{offset:"1",stopColor:a.b})]}),L.jsxs("radialGradient",{id:`${J}secondary${c}${f}`,children:[L.jsx("stop",{offset:"0",stopColor:a.c}),L.jsx("stop",{offset:"1",stopColor:a.b})]})]},f))]}),L.jsxs("g",{clipPath:`url(#${J}circle-clip${c})`,children:[L.jsx("rect",{width:"100%",height:"100%",fill:`url(#${J}background${c})`}),L.jsx("g",{filter:`url(#${J}blur-xs${c})`,children:o.map((a,f)=>L.jsxs(Pe.Fragment,{children:[L.jsx("circle",{fill:`url(#${J}primary${c}${f})`,cx:a.x,cy:a.y,r:a.r}),L.jsx("circle",{fill:`url(#${J}secondary${c}${f})`,cx:a.y,cy:a.x,r:a.r/2})]},f))})]})]})});try{Xe.displayName="GradientAvatar",Xe.__docgenInfo={description:"",displayName:"GradientAvatar",props:{address:{defaultValue:null,description:"",name:"address",required:!0,type:{name:"string"}},initials:{defaultValue:null,description:"",name:"initials",required:!1,type:{name:"string"}},complexity:{defaultValue:null,description:"",name:"complexity",required:!1,type:{name:"number"}},className:{defaultValue:null,description:"",name:"className",required:!1,type:{name:"string"}},size:{defaultValue:null,description:"",name:"size",required:!1,type:{name:'"xs" | "sm" | "md" | "lg" | "xl" | null'}}}}}catch{}const Ds="bulb cute board file buddy subway memory exercise busy repair foam item",so={title:"Components/GradientAvatar",component:Xe},Ge={args:{address:"0x1234567890123456789012345678901234567890"}},Gs=3,Zs=8,an=[["0x8e3E38fe7367dd3b52D1e281E4e8400447C8d8B9","0x73F8E47dEe63002378E047fA74e6DFb24F88f496","0x9Cb019C2FfcD9E9BB83e269625a170179Ff3ECD0","0x9b436D9599FAc498e1e0Ab4D48cDFC72922a6F1e","0x9aB58Bda3eeCbF391a17592ed7626727b922a18f","0x468E8e29F6cfb0F6b7ff10ec6A1AB516ec849c04","0x450cB9fbB2D44d166AACA1f6cDb1dBd9Ff168e4C","0x88cc3E896C4C178AB98333dCD29C33d2cc2102A8"],["0x8e3E38fe7367dd3b52D1e281E4e8400447C8d8Bx","0x73F8E47dEe63002378E047fA74e6DFb24F88f49x","0x9Cb019C2FfcD9E9BB83e269625a170179Ff3ECDx","0x9b436D9599FAc498e1e0Ab4D48cDFC72922a6F1x","0x9aB58Bda3eeCbF391a17592ed7626727b922a18x","0x468E8e29F6cfb0F6b7ff10ec6A1AB516ec849c0x","0x450cB9fbB2D44d166AACA1f6cDb1dBd9Ff168e4x","0x88cc3E896C4C178AB98333dCD29C33d2cc2102Ax"]],Ws=(e,t,r)=>{const{publicKey:n}=Ts(e).derive(Ns({account:t,change:r})),i=Vi(n);return Ft(i)};for(let e=0;e<Gs;e++){const t=[];for(let r=0;r<Zs;r++)t.push(Ws(Ds,e,r));an.push(t)}const Ze=()=>L.jsxs(L.Fragment,{children:[L.jsx(fn,{variant:"normal",color:"primary",fontWeight:"bold",asChild:!0,children:L.jsx("div",{children:"SVG"})}),L.jsx("div",{className:"flex flex-col gap-4",children:an.map((e,t)=>L.jsx("div",{className:"flex gap-4",children:e.map(r=>L.jsx(Xe,{address:r,size:"xl"},r))},t))})]});var lr,dr,hr;Ge.parameters={...Ge.parameters,docs:{...(lr=Ge.parameters)==null?void 0:lr.docs,source:{originalSource:`{
  args: {
    address: '0x1234567890123456789012345678901234567890'
  }
}`,...(hr=(dr=Ge.parameters)==null?void 0:dr.docs)==null?void 0:hr.source}}};var pr,br,gr;Ze.parameters={...Ze.parameters,docs:{...(pr=Ze.parameters)==null?void 0:pr.docs,source:{originalSource:`() => {
  return <>
      <Text variant="normal" color="primary" fontWeight="bold" asChild>
        <div>SVG</div>
      </Text>

      <div className="flex flex-col gap-4">
        {rows.map((cols, idx) => <div className="flex gap-4" key={idx}>
            {cols.map(address => <GradientAvatar key={address} address={address} size="xl" />)}
          </div>)}
      </div>
    </>;
}`,...(gr=(br=Ze.parameters)==null?void 0:br.docs)==null?void 0:gr.source}}};const oo=["Default","Multiple"];export{Ge as Default,Ze as Multiple,oo as __namedExportsOrder,so as default};
