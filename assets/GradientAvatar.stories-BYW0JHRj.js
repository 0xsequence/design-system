import{j as L}from"./jsx-runtime-Cf8x2fCZ.js";import{T as an}from"./Text-CX0KV9o3.js";import{c as fn}from"./index-Dp3B9jqt.js";import{r as qe}from"./index-DubqEmGm.js";import{c as un}from"./classnames-D6E8UiG_.js";import"./index-yBjzXJbu.js";import"./index-BkTKsPvT.js";import"./clsx-B-dksMZM.js";const ln="0.1.1";function dn(){return ln}class _ extends Error{constructor(t,r={}){const n=(()=>{var a;if(r.cause instanceof _){if(r.cause.details)return r.cause.details;if(r.cause.shortMessage)return r.cause.shortMessage}return(a=r.cause)!=null&&a.message?r.cause.message:r.details})(),i=r.cause instanceof _&&r.cause.docsPath||r.docsPath,o=`https://oxlib.sh${i??""}`,c=[t||"An error occurred.",...r.metaMessages?["",...r.metaMessages]:[],...n||i?["",n?`Details: ${n}`:void 0,i?`See: ${o}`:void 0]:[]].filter(a=>typeof a=="string").join(`
`);super(c,r.cause?{cause:r.cause}:void 0),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"BaseError"}),Object.defineProperty(this,"version",{enumerable:!0,configurable:!0,writable:!0,value:`ox@${dn()}`}),this.cause=r.cause,this.details=n,this.docs=o,this.docsPath=i,this.shortMessage=t}walk(t){return yr(this,t)}}function yr(e,t){return t!=null&&t(e)?e:e&&typeof e=="object"&&"cause"in e&&e.cause?yr(e.cause,t):t?null:e}function be(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function hn(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function G(e,...t){if(!hn(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function mr(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");be(e.outputLen),be(e.blockLen)}function He(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Er(e,t){G(e);const r=t.outputLen;if(e.length<r)throw new Error("digestInto() expects output buffer of length at least "+r)}const Se=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function pn(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}function ge(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function X(e,t){return e<<32-t|e>>>t}function Ve(e,t){return e<<t|e>>>32-t>>>0}const qt=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function bn(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}function Vt(e){for(let t=0;t<e.length;t++)e[t]=bn(e[t])}const gn=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function wn(e){G(e);let t="";for(let r=0;r<e.length;r++)t+=gn[e[r]];return t}const ee={_0:48,_9:57,A:65,F:70,a:97,f:102};function Dt(e){if(e>=ee._0&&e<=ee._9)return e-ee._0;if(e>=ee.A&&e<=ee.F)return e-(ee.A-10);if(e>=ee.a&&e<=ee.f)return e-(ee.a-10)}function xn(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);const t=e.length,r=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(r);for(let i=0,s=0;i<r;i++,s+=2){const o=Dt(e.charCodeAt(s)),c=Dt(e.charCodeAt(s+1));if(o===void 0||c===void 0){const a=e[s]+e[s+1];throw new Error('hex string expected, got non-hex character "'+a+'" at index '+s)}n[i]=o*16+c}return n}function Br(e){if(typeof e!="string")throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array(new TextEncoder().encode(e))}function Ce(e){return typeof e=="string"&&(e=Br(e)),G(e),e}function Ke(...e){let t=0;for(let n=0;n<e.length;n++){const i=e[n];G(i),t+=i.length}const r=new Uint8Array(t);for(let n=0,i=0;n<e.length;n++){const s=e[n];r.set(s,i),i+=s.length}return r}class Ut{clone(){return this._cloneInto()}}function yn(e,t){if(t!==void 0&&{}.toString.call(t)!=="[object Object]")throw new Error("Options should be object or undefined");return Object.assign(e,t)}function tt(e){const t=n=>e().update(Ce(n)).digest(),r=e();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>e(),t}function mn(e=32){if(Se&&typeof Se.getRandomValues=="function")return Se.getRandomValues(new Uint8Array(e));if(Se&&typeof Se.randomBytes=="function")return Se.randomBytes(e);throw new Error("crypto.getRandomValues must be defined")}function En(e,t,r,n){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,r,n);const i=BigInt(32),s=BigInt(4294967295),o=Number(r>>i&s),c=Number(r&s),a=n?4:0,f=n?0:4;e.setUint32(t+a,o,n),e.setUint32(t+f,c,n)}function Bn(e,t,r){return e&t^~e&r}function vn(e,t,r){return e&t^e&r^t&r}class kt extends Ut{constructor(t,r,n,i){super(),this.blockLen=t,this.outputLen=r,this.padOffset=n,this.isLE=i,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=ge(this.buffer)}update(t){He(this);const{view:r,buffer:n,blockLen:i}=this;t=Ce(t);const s=t.length;for(let o=0;o<s;){const c=Math.min(i-this.pos,s-o);if(c===i){const a=ge(t);for(;i<=s-o;o+=i)this.process(a,o);continue}n.set(t.subarray(o,o+c),this.pos),this.pos+=c,o+=c,this.pos===i&&(this.process(r,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){He(this),Er(t,this),this.finished=!0;const{buffer:r,view:n,blockLen:i,isLE:s}=this;let{pos:o}=this;r[o++]=128,this.buffer.subarray(o).fill(0),this.padOffset>i-o&&(this.process(n,0),o=0);for(let d=o;d<i;d++)r[d]=0;En(n,i-8,BigInt(this.length*8),s),this.process(n,0);const c=ge(t),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const f=a/4,h=this.get();if(f>h.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<f;d++)c.setUint32(4*d,h[d],s)}digest(){const{buffer:t,outputLen:r}=this;this.digestInto(t);const n=t.slice(0,r);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:r,buffer:n,length:i,finished:s,destroyed:o,pos:c}=this;return t.length=i,t.pos=c,t.finished=s,t.destroyed=o,i%r&&t.buffer.set(n),t}}const An=new Uint8Array([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),vr=new Uint8Array(new Array(16).fill(0).map((e,t)=>t)),Sn=vr.map(e=>(9*e+5)%16);let Lt=[vr],Nt=[Sn];for(let e=0;e<4;e++)for(let t of[Lt,Nt])t.push(t[e].map(r=>An[r]));const Ar=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(e=>new Uint8Array(e)),In=Lt.map((e,t)=>e.map(r=>Ar[t][r])),$n=Nt.map((e,t)=>e.map(r=>Ar[t][r])),On=new Uint32Array([0,1518500249,1859775393,2400959708,2840853838]),Hn=new Uint32Array([1352829926,1548603684,1836072691,2053994217,0]);function Gt(e,t,r,n){return e===0?t^r^n:e===1?t&r|~t&n:e===2?(t|~r)^n:e===3?t&n|r&~n:t^(r|~n)}const De=new Uint32Array(16);class Cn extends kt{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:t,h1:r,h2:n,h3:i,h4:s}=this;return[t,r,n,i,s]}set(t,r,n,i,s){this.h0=t|0,this.h1=r|0,this.h2=n|0,this.h3=i|0,this.h4=s|0}process(t,r){for(let p=0;p<16;p++,r+=4)De[p]=t.getUint32(r,!0);let n=this.h0|0,i=n,s=this.h1|0,o=s,c=this.h2|0,a=c,f=this.h3|0,h=f,d=this.h4|0,l=d;for(let p=0;p<5;p++){const m=4-p,g=On[p],u=Hn[p],b=Lt[p],B=Nt[p],w=In[p],$=$n[p];for(let A=0;A<16;A++){const O=Ve(n+Gt(p,s,c,f)+De[b[A]]+g,w[A])+d|0;n=d,d=f,f=Ve(c,10)|0,c=s,s=O}for(let A=0;A<16;A++){const O=Ve(i+Gt(m,o,a,h)+De[B[A]]+u,$[A])+l|0;i=l,l=h,h=Ve(a,10)|0,a=o,o=O}}this.set(this.h1+c+h|0,this.h2+f+l|0,this.h3+d+i|0,this.h4+n+o|0,this.h0+s+a|0)}roundClean(){De.fill(0)}destroy(){this.destroyed=!0,this.buffer.fill(0),this.set(0,0,0,0,0)}}const Un=tt(()=>new Cn),Ge=BigInt(2**32-1),mt=BigInt(32);function Sr(e,t=!1){return t?{h:Number(e&Ge),l:Number(e>>mt&Ge)}:{h:Number(e>>mt&Ge)|0,l:Number(e&Ge)|0}}function Ir(e,t=!1){let r=new Uint32Array(e.length),n=new Uint32Array(e.length);for(let i=0;i<e.length;i++){const{h:s,l:o}=Sr(e[i],t);[r[i],n[i]]=[s,o]}return[r,n]}const kn=(e,t)=>BigInt(e>>>0)<<mt|BigInt(t>>>0),Ln=(e,t,r)=>e>>>r,Nn=(e,t,r)=>e<<32-r|t>>>r,zn=(e,t,r)=>e>>>r|t<<32-r,jn=(e,t,r)=>e<<32-r|t>>>r,_n=(e,t,r)=>e<<64-r|t>>>r-32,Pn=(e,t,r)=>e>>>r-32|t<<64-r,Kn=(e,t)=>t,Tn=(e,t)=>e,$r=(e,t,r)=>e<<r|t>>>32-r,Or=(e,t,r)=>t<<r|e>>>32-r,Hr=(e,t,r)=>t<<r-32|e>>>64-r,Cr=(e,t,r)=>e<<r-32|t>>>64-r;function Fn(e,t,r,n){const i=(t>>>0)+(n>>>0);return{h:e+r+(i/2**32|0)|0,l:i|0}}const Rn=(e,t,r)=>(e>>>0)+(t>>>0)+(r>>>0),Mn=(e,t,r,n)=>t+r+n+(e/2**32|0)|0,qn=(e,t,r,n)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0),Vn=(e,t,r,n,i)=>t+r+n+i+(e/2**32|0)|0,Dn=(e,t,r,n,i)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0)+(i>>>0),Gn=(e,t,r,n,i,s)=>t+r+n+i+s+(e/2**32|0)|0,H={fromBig:Sr,split:Ir,toBig:kn,shrSH:Ln,shrSL:Nn,rotrSH:zn,rotrSL:jn,rotrBH:_n,rotrBL:Pn,rotr32H:Kn,rotr32L:Tn,rotlSH:$r,rotlSL:Or,rotlBH:Hr,rotlBL:Cr,add:Fn,add3L:Rn,add3H:Mn,add4L:qn,add4H:Vn,add5H:Gn,add5L:Dn},Ur=[],kr=[],Lr=[],Zn=BigInt(0),Pe=BigInt(1),Yn=BigInt(2),Wn=BigInt(7),Xn=BigInt(256),Jn=BigInt(113);for(let e=0,t=Pe,r=1,n=0;e<24;e++){[r,n]=[n,(2*r+3*n)%5],Ur.push(2*(5*n+r)),kr.push((e+1)*(e+2)/2%64);let i=Zn;for(let s=0;s<7;s++)t=(t<<Pe^(t>>Wn)*Jn)%Xn,t&Yn&&(i^=Pe<<(Pe<<BigInt(s))-Pe);Lr.push(i)}const[Qn,ei]=Ir(Lr,!0),Zt=(e,t,r)=>r>32?Hr(e,t,r):$r(e,t,r),Yt=(e,t,r)=>r>32?Cr(e,t,r):Or(e,t,r);function ti(e,t=24){const r=new Uint32Array(10);for(let n=24-t;n<24;n++){for(let o=0;o<10;o++)r[o]=e[o]^e[o+10]^e[o+20]^e[o+30]^e[o+40];for(let o=0;o<10;o+=2){const c=(o+8)%10,a=(o+2)%10,f=r[a],h=r[a+1],d=Zt(f,h,1)^r[c],l=Yt(f,h,1)^r[c+1];for(let p=0;p<50;p+=10)e[o+p]^=d,e[o+p+1]^=l}let i=e[2],s=e[3];for(let o=0;o<24;o++){const c=kr[o],a=Zt(i,s,c),f=Yt(i,s,c),h=Ur[o];i=e[h],s=e[h+1],e[h]=a,e[h+1]=f}for(let o=0;o<50;o+=10){for(let c=0;c<10;c++)r[c]=e[o+c];for(let c=0;c<10;c++)e[o+c]^=~r[(c+2)%10]&r[(c+4)%10]}e[0]^=Qn[n],e[1]^=ei[n]}r.fill(0)}class zt extends Ut{constructor(t,r,n,i=!1,s=24){if(super(),this.blockLen=t,this.suffix=r,this.outputLen=n,this.enableXOF=i,this.rounds=s,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,be(n),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=pn(this.state)}keccak(){qt||Vt(this.state32),ti(this.state32,this.rounds),qt||Vt(this.state32),this.posOut=0,this.pos=0}update(t){He(this);const{blockLen:r,state:n}=this;t=Ce(t);const i=t.length;for(let s=0;s<i;){const o=Math.min(r-this.pos,i-s);for(let c=0;c<o;c++)n[this.pos++]^=t[s++];this.pos===r&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:r,pos:n,blockLen:i}=this;t[n]^=r,r&128&&n===i-1&&this.keccak(),t[i-1]^=128,this.keccak()}writeInto(t){He(this,!1),G(t),this.finish();const r=this.state,{blockLen:n}=this;for(let i=0,s=t.length;i<s;){this.posOut>=n&&this.keccak();const o=Math.min(n-this.posOut,s-i);t.set(r.subarray(this.posOut,this.posOut+o),i),this.posOut+=o,i+=o}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return be(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(Er(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:r,suffix:n,outputLen:i,rounds:s,enableXOF:o}=this;return t||(t=new zt(r,n,i,o,s)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=s,t.suffix=n,t.outputLen=i,t.enableXOF=o,t.destroyed=this.destroyed,t}}const ri=(e,t,r)=>tt(()=>new zt(t,e,r)),ni=ri(1,136,256/8),ii=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),oe=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ce=new Uint32Array(64);class si extends kt{constructor(){super(64,32,8,!1),this.A=oe[0]|0,this.B=oe[1]|0,this.C=oe[2]|0,this.D=oe[3]|0,this.E=oe[4]|0,this.F=oe[5]|0,this.G=oe[6]|0,this.H=oe[7]|0}get(){const{A:t,B:r,C:n,D:i,E:s,F:o,G:c,H:a}=this;return[t,r,n,i,s,o,c,a]}set(t,r,n,i,s,o,c,a){this.A=t|0,this.B=r|0,this.C=n|0,this.D=i|0,this.E=s|0,this.F=o|0,this.G=c|0,this.H=a|0}process(t,r){for(let d=0;d<16;d++,r+=4)ce[d]=t.getUint32(r,!1);for(let d=16;d<64;d++){const l=ce[d-15],p=ce[d-2],m=X(l,7)^X(l,18)^l>>>3,g=X(p,17)^X(p,19)^p>>>10;ce[d]=g+ce[d-7]+m+ce[d-16]|0}let{A:n,B:i,C:s,D:o,E:c,F:a,G:f,H:h}=this;for(let d=0;d<64;d++){const l=X(c,6)^X(c,11)^X(c,25),p=h+l+Bn(c,a,f)+ii[d]+ce[d]|0,g=(X(n,2)^X(n,13)^X(n,22))+vn(n,i,s)|0;h=f,f=a,a=c,c=o+p|0,o=s,s=i,i=n,n=p+g|0}n=n+this.A|0,i=i+this.B|0,s=s+this.C|0,o=o+this.D|0,c=c+this.E|0,a=a+this.F|0,f=f+this.G|0,h=h+this.H|0,this.set(n,i,s,o,c,a,f,h)}roundClean(){ce.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const jt=tt(()=>new si);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const rt=BigInt(0),nt=BigInt(1),oi=BigInt(2);function ye(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Re(e){if(!ye(e))throw new Error("Uint8Array expected")}function Ue(e,t){if(typeof t!="boolean")throw new Error(e+" boolean expected, got "+t)}const ci=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function ke(e){Re(e);let t="";for(let r=0;r<e.length;r++)t+=ci[e[r]];return t}function $e(e){const t=e.toString(16);return t.length&1?"0"+t:t}function _t(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?rt:BigInt("0x"+e)}const te={_0:48,_9:57,A:65,F:70,a:97,f:102};function Wt(e){if(e>=te._0&&e<=te._9)return e-te._0;if(e>=te.A&&e<=te.F)return e-(te.A-10);if(e>=te.a&&e<=te.f)return e-(te.a-10)}function Le(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);const t=e.length,r=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(r);for(let i=0,s=0;i<r;i++,s+=2){const o=Wt(e.charCodeAt(s)),c=Wt(e.charCodeAt(s+1));if(o===void 0||c===void 0){const a=e[s]+e[s+1];throw new Error('hex string expected, got non-hex character "'+a+'" at index '+s)}n[i]=o*16+c}return n}function we(e){return _t(ke(e))}function Pt(e){return Re(e),_t(ke(Uint8Array.from(e).reverse()))}function Ne(e,t){return Le(e.toString(16).padStart(t*2,"0"))}function Kt(e,t){return Ne(e,t).reverse()}function ai(e){return Le($e(e))}function Y(e,t,r){let n;if(typeof t=="string")try{n=Le(t)}catch(s){throw new Error(e+" must be hex string or Uint8Array, cause: "+s)}else if(ye(t))n=Uint8Array.from(t);else throw new Error(e+" must be hex string or Uint8Array");const i=n.length;if(typeof r=="number"&&i!==r)throw new Error(e+" of length "+r+" expected, got "+i);return n}function Te(...e){let t=0;for(let n=0;n<e.length;n++){const i=e[n];Re(i),t+=i.length}const r=new Uint8Array(t);for(let n=0,i=0;n<e.length;n++){const s=e[n];r.set(s,i),i+=s.length}return r}function fi(e,t){if(e.length!==t.length)return!1;let r=0;for(let n=0;n<e.length;n++)r|=e[n]^t[n];return r===0}function ui(e){if(typeof e!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}const ct=e=>typeof e=="bigint"&&rt<=e;function it(e,t,r){return ct(e)&&ct(t)&&ct(r)&&t<=e&&e<r}function xe(e,t,r,n){if(!it(t,r,n))throw new Error("expected valid "+e+": "+r+" <= n < "+n+", got "+t)}function Nr(e){let t;for(t=0;e>rt;e>>=nt,t+=1);return t}function li(e,t){return e>>BigInt(t)&nt}function di(e,t,r){return e|(r?nt:rt)<<BigInt(t)}const Tt=e=>(oi<<BigInt(e-1))-nt,at=e=>new Uint8Array(e),Xt=e=>Uint8Array.from(e);function zr(e,t,r){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof r!="function")throw new Error("hmacFn must be a function");let n=at(e),i=at(e),s=0;const o=()=>{n.fill(1),i.fill(0),s=0},c=(...d)=>r(i,n,...d),a=(d=at())=>{i=c(Xt([0]),d),n=c(),d.length!==0&&(i=c(Xt([1]),d),n=c())},f=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let d=0;const l=[];for(;d<t;){n=c();const p=n.slice();l.push(p),d+=n.length}return Te(...l)};return(d,l)=>{o(),a(d);let p;for(;!(p=l(f()));)a();return o(),p}}const hi={bigint:e=>typeof e=="bigint",function:e=>typeof e=="function",boolean:e=>typeof e=="boolean",string:e=>typeof e=="string",stringOrUint8Array:e=>typeof e=="string"||ye(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>typeof e=="function"&&Number.isSafeInteger(e.outputLen)};function Me(e,t,r={}){const n=(i,s,o)=>{const c=hi[s];if(typeof c!="function")throw new Error("invalid validator function");const a=e[i];if(!(o&&a===void 0)&&!c(a,e))throw new Error("param "+String(i)+" is invalid. Expected "+s+", got "+a)};for(const[i,s]of Object.entries(t))n(i,s,!1);for(const[i,s]of Object.entries(r))n(i,s,!0);return e}const pi=()=>{throw new Error("not implemented")};function Et(e){const t=new WeakMap;return(r,...n)=>{const i=t.get(r);if(i!==void 0)return i;const s=e(r,...n);return t.set(r,s),s}}const bi=Object.freeze(Object.defineProperty({__proto__:null,aInRange:xe,abool:Ue,abytes:Re,bitGet:li,bitLen:Nr,bitMask:Tt,bitSet:di,bytesToHex:ke,bytesToNumberBE:we,bytesToNumberLE:Pt,concatBytes:Te,createHmacDrbg:zr,ensureBytes:Y,equalBytes:fi,hexToBytes:Le,hexToNumber:_t,inRange:it,isBytes:ye,memoized:Et,notImplemented:pi,numberToBytesBE:Ne,numberToBytesLE:Kt,numberToHexUnpadded:$e,numberToVarBytesBE:ai,utf8ToBytes:ui,validateObject:Me},Symbol.toStringTag,{value:"Module"})),gi="#__bigint";function Ft(e,t,r){return JSON.stringify(e,(n,i)=>typeof i=="bigint"?i.toString()+gi:i,r)}function wi(e,t){if(tr(e)>t)throw new _i({givenSize:tr(e),maxSize:t})}const re={zero:48,nine:57,A:65,F:70,a:97,f:102};function Jt(e){if(e>=re.zero&&e<=re.nine)return e-re.zero;if(e>=re.A&&e<=re.F)return e-(re.A-10);if(e>=re.a&&e<=re.f)return e-(re.a-10)}function xi(e,t={}){const{dir:r,size:n=32}=t;if(n===0)return e;if(e.length>n)throw new Pi({size:e.length,targetSize:n,type:"Bytes"});const i=new Uint8Array(n);for(let s=0;s<n;s++){const o=r==="right";i[o?s:n-s-1]=e[o?s:e.length-s-1]}return i}function jr(e,t){if(Ee(e)>t)throw new $i({givenSize:Ee(e),maxSize:t})}function yi(e,t){if(typeof t=="number"&&t>0&&t>Ee(e)-1)throw new Tr({offset:t,position:"start",size:Ee(e)})}function mi(e,t,r){if(typeof t=="number"&&typeof r=="number"&&Ee(e)!==r-t)throw new Tr({offset:r,position:"end",size:Ee(e)})}function _r(e,t={}){const{dir:r,size:n=32}=t;if(n===0)return e;const i=e.replace("0x","");if(i.length>n*2)throw new Oi({size:Math.ceil(i.length/2),targetSize:n,type:"Hex"});return`0x${i[r==="right"?"padEnd":"padStart"](n*2,"0")}`}const Ei=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function Bi(e,t={}){const{strict:r=!1}=t;if(!e)throw new Qt(e);if(typeof e!="string")throw new Qt(e);if(r&&!/^0x[0-9a-fA-F]*$/.test(e))throw new er(e);if(!e.startsWith("0x"))throw new er(e)}function vi(...e){return`0x${e.reduce((t,r)=>t+r.replace("0x",""),"")}`}function Pr(e){return e instanceof Uint8Array?me(e):Array.isArray(e)?me(new Uint8Array(e)):e}function me(e,t={}){let r="";for(let i=0;i<e.length;i++)r+=Ei[e[i]];const n=`0x${r}`;return typeof t.size=="number"?(jr(n,t.size),Kr(n,t.size)):n}function ft(e,t={}){const{signed:r,size:n}=t,i=BigInt(e);let s;n?r?s=(1n<<BigInt(n)*8n-1n)-1n:s=2n**(BigInt(n)*8n)-1n:typeof e=="number"&&(s=BigInt(Number.MAX_SAFE_INTEGER));const o=typeof s=="bigint"&&r?-s-1n:0;if(s&&i>s||i<o){const f=typeof e=="bigint"?"n":"";throw new Ii({max:s?`${s}${f}`:void 0,min:`${o}${f}`,signed:r,size:n,value:`${e}${f}`})}const a=`0x${(r&&i<0?(1n<<BigInt(n*8))+BigInt(i):i).toString(16)}`;return n?Ai(a,n):a}function Ai(e,t){return _r(e,{dir:"left",size:t})}function Kr(e,t){return _r(e,{dir:"right",size:t})}function de(e,t,r,n={}){const{strict:i}=n;yi(e,t);const s=`0x${e.replace("0x","").slice((t??0)*2,(r??e.length)*2)}`;return i&&mi(s,t,r),s}function Ee(e){return Math.ceil((e.length-2)/2)}function Si(e,t={}){const{strict:r=!1}=t;try{return Bi(e,{strict:r}),!0}catch{return!1}}class Ii extends _{constructor({max:t,min:r,signed:n,size:i,value:s}){super(`Number \`${s}\` is not in safe${i?` ${i*8}-bit`:""}${n?" signed":" unsigned"} integer range ${t?`(\`${r}\` to \`${t}\`)`:`(above \`${r}\`)`}`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Hex.IntegerOutOfRangeError"})}}class Qt extends _{constructor(t){super(`Value \`${typeof t=="object"?Ft(t):t}\` of type \`${typeof t}\` is an invalid hex type.`,{metaMessages:['Hex types must be represented as `"0x${string}"`.']}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Hex.InvalidHexTypeError"})}}class er extends _{constructor(t){super(`Value \`${t}\` is an invalid hex value.`,{metaMessages:['Hex values must start with `"0x"` and contain only hexadecimal characters (0-9, a-f, A-F).']}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Hex.InvalidHexValueError"})}}let $i=class extends _{constructor({givenSize:t,maxSize:r}){super(`Size cannot exceed \`${r}\` bytes. Given size: \`${t}\` bytes.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Hex.SizeOverflowError"})}};class Tr extends _{constructor({offset:t,position:r,size:n}){super(`Slice ${r==="start"?"starting":"ending"} at offset \`${t}\` is out-of-bounds (size: \`${n}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Hex.SliceOffsetOutOfBoundsError"})}}let Oi=class extends _{constructor({size:t,targetSize:r,type:n}){super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (\`${t}\`) exceeds padding size (\`${r}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Hex.SizeExceedsPaddingSizeError"})}};const Hi=new TextEncoder;function Ci(e){if(!(e instanceof Uint8Array)){if(!e)throw new Ze(e);if(typeof e!="object")throw new Ze(e);if(!("BYTES_PER_ELEMENT"in e))throw new Ze(e);if(e.BYTES_PER_ELEMENT!==1||e.constructor.name!=="Uint8Array")throw new Ze(e)}}function Fr(e){return e instanceof Uint8Array?e:typeof e=="string"?ki(e):Ui(e)}function Ui(e){return e instanceof Uint8Array?e:new Uint8Array(e)}function ki(e,t={}){const{size:r}=t;let n=e;r&&(jr(e,r),n=Kr(e,r));let i=n.slice(2);i.length%2&&(i=`0${i}`);const s=i.length/2,o=new Uint8Array(s);for(let c=0,a=0;c<s;c++){const f=Jt(i.charCodeAt(a++)),h=Jt(i.charCodeAt(a++));if(f===void 0||h===void 0)throw new _(`Invalid byte sequence ("${i[a-2]}${i[a-1]}" in "${i}").`);o[c]=f*16+h}return o}function Li(e,t={}){const{size:r}=t,n=Hi.encode(e);return typeof r=="number"?(wi(n,r),Ni(n,r)):n}function Ni(e,t){return xi(e,{dir:"right",size:t})}function tr(e){return e.length}function zi(e,t={}){return me(e,t)}function ji(e){try{return Ci(e),!0}catch{return!1}}class Ze extends _{constructor(t){super(`Value \`${typeof t=="object"?Ft(t):t}\` of type \`${typeof t}\` is an invalid Bytes value.`,{metaMessages:["Bytes values must be of type `Bytes`."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Bytes.InvalidBytesTypeError"})}}class _i extends _{constructor({givenSize:t,maxSize:r}){super(`Size cannot exceed \`${r}\` bytes. Given size: \`${t}\` bytes.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Bytes.SizeOverflowError"})}}class Pi extends _{constructor({size:t,targetSize:r,type:n}){super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (\`${t}\`) exceeds padding size (\`${r}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Bytes.SizeExceedsPaddingSizeError"})}}function Rr(e,t={}){const{as:r=typeof e=="string"?"Hex":"Bytes"}=t,n=ni(Fr(e));return r==="Bytes"?n:me(n)}class Ki extends Map{constructor(t){super(),Object.defineProperty(this,"maxSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxSize=t}get(t){const r=super.get(t);return super.has(t)&&r!==void 0&&(this.delete(t),super.set(t,r)),r}set(t,r){if(super.set(t,r),this.maxSize&&this.size>this.maxSize){const n=this.keys().next().value;n&&this.delete(n)}return this}}const Ti={checksum:new Ki(8192)},ut=Ti.checksum;function Mr(e,t={}){const{compressed:r}=t,{prefix:n,x:i,y:s}=e;if(r===!1||typeof i=="bigint"&&typeof s=="bigint"){if(n!==4)throw new rr({prefix:n,cause:new Di});return}if(r===!0||typeof i=="bigint"&&typeof s>"u"){if(n!==3&&n!==2)throw new rr({prefix:n,cause:new Vi});return}throw new qi({publicKey:e})}function Fi(e){const t=(()=>{if(Si(e))return qr(e);if(ji(e))return Ri(e);const{prefix:r,x:n,y:i}=e;return typeof n=="bigint"&&typeof i=="bigint"?{prefix:r??4,x:n,y:i}:{prefix:r,x:n}})();return Mr(t),t}function Ri(e){return qr(me(e))}function qr(e){if(e.length!==132&&e.length!==130&&e.length!==68)throw new Gi({publicKey:e});if(e.length===130){const n=BigInt(de(e,0,32)),i=BigInt(de(e,32,64));return{prefix:4,x:n,y:i}}if(e.length===132){const n=Number(de(e,0,1)),i=BigInt(de(e,1,33)),s=BigInt(de(e,33,65));return{prefix:n,x:i,y:s}}const t=Number(de(e,0,1)),r=BigInt(de(e,1,33));return{prefix:t,x:r}}function Mi(e,t={}){Mr(e);const{prefix:r,x:n,y:i}=e,{includePrefix:s=!0}=t;return vi(s?ft(r,{size:1}):"0x",ft(n,{size:32}),typeof i=="bigint"?ft(i,{size:32}):"0x")}class qi extends _{constructor({publicKey:t}){super(`Value \`${Ft(t)}\` is not a valid public key.`,{metaMessages:["Public key must contain:","- an `x` and `prefix` value (compressed)","- an `x`, `y`, and `prefix` value (uncompressed)"]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"PublicKey.InvalidError"})}}class rr extends _{constructor({prefix:t,cause:r}){super(`Prefix "${t}" is invalid.`,{cause:r}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"PublicKey.InvalidPrefixError"})}}class Vi extends _{constructor(){super("Prefix must be 2 or 3 for compressed public keys."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"PublicKey.InvalidCompressedPrefixError"})}}class Di extends _{constructor(){super("Prefix must be 4 for uncompressed public keys."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"PublicKey.InvalidUncompressedPrefixError"})}}class Gi extends _{constructor({publicKey:t}){super(`Value \`${t}\` is an invalid public key size.`,{metaMessages:["Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).",`Received ${Ee(Pr(t))} bytes.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"PublicKey.InvalidSerializedSizeError"})}}const Zi=/^0x[a-fA-F0-9]{40}$/;function Vr(e,t={}){const{strict:r=!0}=t;if(!Zi.test(e))throw new nr({address:e,cause:new Xi});if(r){if(e.toLowerCase()===e)return;if(Rt(e)!==e)throw new nr({address:e,cause:new Ji})}}function Rt(e){if(ut.has(e))return ut.get(e);Vr(e,{strict:!1});const t=e.substring(2).toLowerCase(),r=Rr(Li(t),{as:"Bytes"}),n=t.split("");for(let s=0;s<40;s+=2)r[s>>1]>>4>=8&&n[s]&&(n[s]=n[s].toUpperCase()),(r[s>>1]&15)>=8&&n[s+1]&&(n[s+1]=n[s+1].toUpperCase());const i=`0x${n.join("")}`;return ut.set(e,i),i}function Yi(e,t={}){const{checksum:r=!1}=t;return Vr(e),r?Rt(e):e}function Wi(e,t={}){const r=Rr(`0x${Mi(e).slice(4)}`).substring(26);return Yi(`0x${r}`,t)}class nr extends _{constructor({address:t,cause:r}){super(`Address "${t}" is invalid.`,{cause:r}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Address.InvalidAddressError"})}}class Xi extends _{constructor(){super("Address is not a 20 byte (40 hexadecimal character) value."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Address.InvalidInputError"})}}class Ji extends _{constructor(){super("Address does not match its checksum counterpart."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Address.InvalidChecksumError"})}}class Dr extends Ut{constructor(t,r){super(),this.finished=!1,this.destroyed=!1,mr(t);const n=Ce(r);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,s=new Uint8Array(i);s.set(n.length>i?t.create().update(n).digest():n);for(let o=0;o<s.length;o++)s[o]^=54;this.iHash.update(s),this.oHash=t.create();for(let o=0;o<s.length;o++)s[o]^=106;this.oHash.update(s),s.fill(0)}update(t){return He(this),this.iHash.update(t),this}digestInto(t){He(this),G(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:r,iHash:n,finished:i,destroyed:s,blockLen:o,outputLen:c}=this;return t=t,t.finished=i,t.destroyed=s,t.blockLen=o,t.outputLen=c,t.oHash=r._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Fe=(e,t,r)=>new Dr(e,t).update(r).digest();Fe.create=(e,t)=>new Dr(e,t);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const T=BigInt(0),j=BigInt(1),he=BigInt(2),Qi=BigInt(3),Bt=BigInt(4),ir=BigInt(5),sr=BigInt(8);function M(e,t){const r=e%t;return r>=T?r:t+r}function es(e,t,r){if(t<T)throw new Error("invalid exponent, negatives unsupported");if(r<=T)throw new Error("invalid modulus");if(r===j)return T;let n=j;for(;t>T;)t&j&&(n=n*e%r),e=e*e%r,t>>=j;return n}function D(e,t,r){let n=e;for(;t-- >T;)n*=n,n%=r;return n}function vt(e,t){if(e===T)throw new Error("invert: expected non-zero number");if(t<=T)throw new Error("invert: expected positive modulus, got "+t);let r=M(e,t),n=t,i=T,s=j;for(;r!==T;){const c=n/r,a=n%r,f=i-s*c;n=r,r=a,i=s,s=f}if(n!==j)throw new Error("invert: does not exist");return M(i,t)}function ts(e){const t=(e-j)/he;let r,n,i;for(r=e-j,n=0;r%he===T;r/=he,n++);for(i=he;i<e&&es(i,t,e)!==e-j;i++)if(i>1e3)throw new Error("Cannot find square root: likely non-prime P");if(n===1){const o=(e+j)/Bt;return function(a,f){const h=a.pow(f,o);if(!a.eql(a.sqr(h),f))throw new Error("Cannot find square root");return h}}const s=(r+j)/he;return function(c,a){if(c.pow(a,t)===c.neg(c.ONE))throw new Error("Cannot find square root");let f=n,h=c.pow(c.mul(c.ONE,i),r),d=c.pow(a,s),l=c.pow(a,r);for(;!c.eql(l,c.ONE);){if(c.eql(l,c.ZERO))return c.ZERO;let p=1;for(let g=c.sqr(l);p<f&&!c.eql(g,c.ONE);p++)g=c.sqr(g);const m=c.pow(h,j<<BigInt(f-p-1));h=c.sqr(m),d=c.mul(d,m),l=c.mul(l,h),f=p}return d}}function rs(e){if(e%Bt===Qi){const t=(e+j)/Bt;return function(n,i){const s=n.pow(i,t);if(!n.eql(n.sqr(s),i))throw new Error("Cannot find square root");return s}}if(e%sr===ir){const t=(e-ir)/sr;return function(n,i){const s=n.mul(i,he),o=n.pow(s,t),c=n.mul(i,o),a=n.mul(n.mul(c,he),o),f=n.mul(c,n.sub(a,n.ONE));if(!n.eql(n.sqr(f),i))throw new Error("Cannot find square root");return f}}return ts(e)}const ns=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function is(e){const t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},r=ns.reduce((n,i)=>(n[i]="function",n),t);return Me(e,r)}function ss(e,t,r){if(r<T)throw new Error("invalid exponent, negatives unsupported");if(r===T)return e.ONE;if(r===j)return t;let n=e.ONE,i=t;for(;r>T;)r&j&&(n=e.mul(n,i)),i=e.sqr(i),r>>=j;return n}function os(e,t){const r=new Array(t.length),n=t.reduce((s,o,c)=>e.is0(o)?s:(r[c]=s,e.mul(s,o)),e.ONE),i=e.inv(n);return t.reduceRight((s,o,c)=>e.is0(o)?s:(r[c]=e.mul(s,r[c]),e.mul(s,o)),i),r}function Gr(e,t){const r=t!==void 0?t:e.toString(2).length,n=Math.ceil(r/8);return{nBitLength:r,nByteLength:n}}function Zr(e,t,r=!1,n={}){if(e<=T)throw new Error("invalid field: expected ORDER > 0, got "+e);const{nBitLength:i,nByteLength:s}=Gr(e,t);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let o;const c=Object.freeze({ORDER:e,isLE:r,BITS:i,BYTES:s,MASK:Tt(i),ZERO:T,ONE:j,create:a=>M(a,e),isValid:a=>{if(typeof a!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof a);return T<=a&&a<e},is0:a=>a===T,isOdd:a=>(a&j)===j,neg:a=>M(-a,e),eql:(a,f)=>a===f,sqr:a=>M(a*a,e),add:(a,f)=>M(a+f,e),sub:(a,f)=>M(a-f,e),mul:(a,f)=>M(a*f,e),pow:(a,f)=>ss(c,a,f),div:(a,f)=>M(a*vt(f,e),e),sqrN:a=>a*a,addN:(a,f)=>a+f,subN:(a,f)=>a-f,mulN:(a,f)=>a*f,inv:a=>vt(a,e),sqrt:n.sqrt||(a=>(o||(o=rs(e)),o(c,a))),invertBatch:a=>os(c,a),cmov:(a,f,h)=>h?f:a,toBytes:a=>r?Kt(a,s):Ne(a,s),fromBytes:a=>{if(a.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+a.length);return r?Pt(a):we(a)}});return Object.freeze(c)}function Yr(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function Wr(e){const t=Yr(e);return t+Math.ceil(t/2)}function cs(e,t,r=!1){const n=e.length,i=Yr(t),s=Wr(t);if(n<16||n<s||n>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+n);const o=r?Pt(e):we(e),c=M(o,t-j)+j;return r?Kt(c,i):Ne(c,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const or=BigInt(0),Ye=BigInt(1);function lt(e,t){const r=t.negate();return e?r:t}function Xr(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+e)}function dt(e,t){Xr(e,t);const r=Math.ceil(t/e)+1,n=2**(e-1);return{windows:r,windowSize:n}}function as(e,t){if(!Array.isArray(e))throw new Error("array expected");e.forEach((r,n)=>{if(!(r instanceof t))throw new Error("invalid point at index "+n)})}function fs(e,t){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((r,n)=>{if(!t.isValid(r))throw new Error("invalid scalar at index "+n)})}const ht=new WeakMap,Jr=new WeakMap;function pt(e){return Jr.get(e)||1}function us(e,t){return{constTimeNegate:lt,hasPrecomputes(r){return pt(r)!==1},unsafeLadder(r,n,i=e.ZERO){let s=r;for(;n>or;)n&Ye&&(i=i.add(s)),s=s.double(),n>>=Ye;return i},precomputeWindow(r,n){const{windows:i,windowSize:s}=dt(n,t),o=[];let c=r,a=c;for(let f=0;f<i;f++){a=c,o.push(a);for(let h=1;h<s;h++)a=a.add(c),o.push(a);c=a.double()}return o},wNAF(r,n,i){const{windows:s,windowSize:o}=dt(r,t);let c=e.ZERO,a=e.BASE;const f=BigInt(2**r-1),h=2**r,d=BigInt(r);for(let l=0;l<s;l++){const p=l*o;let m=Number(i&f);i>>=d,m>o&&(m-=h,i+=Ye);const g=p,u=p+Math.abs(m)-1,b=l%2!==0,B=m<0;m===0?a=a.add(lt(b,n[g])):c=c.add(lt(B,n[u]))}return{p:c,f:a}},wNAFUnsafe(r,n,i,s=e.ZERO){const{windows:o,windowSize:c}=dt(r,t),a=BigInt(2**r-1),f=2**r,h=BigInt(r);for(let d=0;d<o;d++){const l=d*c;if(i===or)break;let p=Number(i&a);if(i>>=h,p>c&&(p-=f,i+=Ye),p===0)continue;let m=n[l+Math.abs(p)-1];p<0&&(m=m.negate()),s=s.add(m)}return s},getPrecomputes(r,n,i){let s=ht.get(n);return s||(s=this.precomputeWindow(n,r),r!==1&&ht.set(n,i(s))),s},wNAFCached(r,n,i){const s=pt(r);return this.wNAF(s,this.getPrecomputes(s,r,i),n)},wNAFCachedUnsafe(r,n,i,s){const o=pt(r);return o===1?this.unsafeLadder(r,n,s):this.wNAFUnsafe(o,this.getPrecomputes(o,r,i),n,s)},setWindowSize(r,n){Xr(n,t),Jr.set(r,n),ht.delete(r)}}}function ls(e,t,r,n){if(as(r,e),fs(n,t),r.length!==n.length)throw new Error("arrays of points and scalars must have equal length");const i=e.ZERO,s=Nr(BigInt(r.length)),o=s>12?s-3:s>4?s-2:s?2:1,c=(1<<o)-1,a=new Array(c+1).fill(i),f=Math.floor((t.BITS-1)/o)*o;let h=i;for(let d=f;d>=0;d-=o){a.fill(i);for(let p=0;p<n.length;p++){const m=n[p],g=Number(m>>BigInt(d)&BigInt(c));a[g]=a[g].add(r[p])}let l=i;for(let p=a.length-1,m=i;p>0;p--)m=m.add(a[p]),l=l.add(m);if(h=h.add(l),d!==0)for(let p=0;p<o;p++)h=h.double()}return h}function Qr(e){return is(e.Fp),Me(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Gr(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function cr(e){e.lowS!==void 0&&Ue("lowS",e.lowS),e.prehash!==void 0&&Ue("prehash",e.prehash)}function ds(e){const t=Qr(e);Me(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:n,a:i}=t;if(r){if(!n.eql(i,n.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof r!="object"||typeof r.beta!="bigint"||typeof r.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...t})}const{bytesToNumberBE:hs,hexToBytes:ps}=bi;class bs extends Error{constructor(t=""){super(t)}}const ne={Err:bs,_tlv:{encode:(e,t)=>{const{Err:r}=ne;if(e<0||e>256)throw new r("tlv.encode: wrong tag");if(t.length&1)throw new r("tlv.encode: unpadded data");const n=t.length/2,i=$e(n);if(i.length/2&128)throw new r("tlv.encode: long form length too big");const s=n>127?$e(i.length/2|128):"";return $e(e)+s+i+t},decode(e,t){const{Err:r}=ne;let n=0;if(e<0||e>256)throw new r("tlv.encode: wrong tag");if(t.length<2||t[n++]!==e)throw new r("tlv.decode: wrong tlv");const i=t[n++],s=!!(i&128);let o=0;if(!s)o=i;else{const a=i&127;if(!a)throw new r("tlv.decode(long): indefinite length not supported");if(a>4)throw new r("tlv.decode(long): byte length is too big");const f=t.subarray(n,n+a);if(f.length!==a)throw new r("tlv.decode: length bytes not complete");if(f[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(const h of f)o=o<<8|h;if(n+=a,o<128)throw new r("tlv.decode(long): not minimal encoding")}const c=t.subarray(n,n+o);if(c.length!==o)throw new r("tlv.decode: wrong value length");return{v:c,l:t.subarray(n+o)}}},_int:{encode(e){const{Err:t}=ne;if(e<ie)throw new t("integer: negative integers are not allowed");let r=$e(e);if(Number.parseInt(r[0],16)&8&&(r="00"+r),r.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return r},decode(e){const{Err:t}=ne;if(e[0]&128)throw new t("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return hs(e)}},toSig(e){const{Err:t,_int:r,_tlv:n}=ne,i=typeof e=="string"?ps(e):e;Re(i);const{v:s,l:o}=n.decode(48,i);if(o.length)throw new t("invalid signature: left bytes after parsing");const{v:c,l:a}=n.decode(2,s),{v:f,l:h}=n.decode(2,a);if(h.length)throw new t("invalid signature: left bytes after parsing");return{r:r.decode(c),s:r.decode(f)}},hexFromSig(e){const{_tlv:t,_int:r}=ne,n=t.encode(2,r.encode(e.r)),i=t.encode(2,r.encode(e.s)),s=n+i;return t.encode(48,s)}},ie=BigInt(0),K=BigInt(1);BigInt(2);const ar=BigInt(3);BigInt(4);function gs(e){const t=ds(e),{Fp:r}=t,n=Zr(t.n,t.nBitLength),i=t.toBytes||((g,u,b)=>{const B=u.toAffine();return Te(Uint8Array.from([4]),r.toBytes(B.x),r.toBytes(B.y))}),s=t.fromBytes||(g=>{const u=g.subarray(1),b=r.fromBytes(u.subarray(0,r.BYTES)),B=r.fromBytes(u.subarray(r.BYTES,2*r.BYTES));return{x:b,y:B}});function o(g){const{a:u,b}=t,B=r.sqr(g),w=r.mul(B,g);return r.add(r.add(w,r.mul(g,u)),b)}if(!r.eql(r.sqr(t.Gy),o(t.Gx)))throw new Error("bad generator point: equation left != right");function c(g){return it(g,K,t.n)}function a(g){const{allowedPrivateKeyLengths:u,nByteLength:b,wrapPrivateKey:B,n:w}=t;if(u&&typeof g!="bigint"){if(ye(g)&&(g=ke(g)),typeof g!="string"||!u.includes(g.length))throw new Error("invalid private key");g=g.padStart(b*2,"0")}let $;try{$=typeof g=="bigint"?g:we(Y("private key",g,b))}catch{throw new Error("invalid private key, expected hex or "+b+" bytes, got "+typeof g)}return B&&($=M($,w)),xe("private key",$,K,w),$}function f(g){if(!(g instanceof l))throw new Error("ProjectivePoint expected")}const h=Et((g,u)=>{const{px:b,py:B,pz:w}=g;if(r.eql(w,r.ONE))return{x:b,y:B};const $=g.is0();u==null&&(u=$?r.ONE:r.inv(w));const A=r.mul(b,u),O=r.mul(B,u),S=r.mul(w,u);if($)return{x:r.ZERO,y:r.ZERO};if(!r.eql(S,r.ONE))throw new Error("invZ was invalid");return{x:A,y:O}}),d=Et(g=>{if(g.is0()){if(t.allowInfinityPoint&&!r.is0(g.py))return;throw new Error("bad point: ZERO")}const{x:u,y:b}=g.toAffine();if(!r.isValid(u)||!r.isValid(b))throw new Error("bad point: x or y not FE");const B=r.sqr(b),w=o(u);if(!r.eql(B,w))throw new Error("bad point: equation left != right");if(!g.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class l{constructor(u,b,B){if(this.px=u,this.py=b,this.pz=B,u==null||!r.isValid(u))throw new Error("x required");if(b==null||!r.isValid(b))throw new Error("y required");if(B==null||!r.isValid(B))throw new Error("z required");Object.freeze(this)}static fromAffine(u){const{x:b,y:B}=u||{};if(!u||!r.isValid(b)||!r.isValid(B))throw new Error("invalid affine point");if(u instanceof l)throw new Error("projective point not allowed");const w=$=>r.eql($,r.ZERO);return w(b)&&w(B)?l.ZERO:new l(b,B,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){const b=r.invertBatch(u.map(B=>B.pz));return u.map((B,w)=>B.toAffine(b[w])).map(l.fromAffine)}static fromHex(u){const b=l.fromAffine(s(Y("pointHex",u)));return b.assertValidity(),b}static fromPrivateKey(u){return l.BASE.multiply(a(u))}static msm(u,b){return ls(l,n,u,b)}_setWindowSize(u){m.setWindowSize(this,u)}assertValidity(){d(this)}hasEvenY(){const{y:u}=this.toAffine();if(r.isOdd)return!r.isOdd(u);throw new Error("Field doesn't support isOdd")}equals(u){f(u);const{px:b,py:B,pz:w}=this,{px:$,py:A,pz:O}=u,S=r.eql(r.mul(b,O),r.mul($,w)),I=r.eql(r.mul(B,O),r.mul(A,w));return S&&I}negate(){return new l(this.px,r.neg(this.py),this.pz)}double(){const{a:u,b}=t,B=r.mul(b,ar),{px:w,py:$,pz:A}=this;let O=r.ZERO,S=r.ZERO,I=r.ZERO,v=r.mul(w,w),z=r.mul($,$),N=r.mul(A,A),U=r.mul(w,$);return U=r.add(U,U),I=r.mul(w,A),I=r.add(I,I),O=r.mul(u,I),S=r.mul(B,N),S=r.add(O,S),O=r.sub(z,S),S=r.add(z,S),S=r.mul(O,S),O=r.mul(U,O),I=r.mul(B,I),N=r.mul(u,N),U=r.sub(v,N),U=r.mul(u,U),U=r.add(U,I),I=r.add(v,v),v=r.add(I,v),v=r.add(v,N),v=r.mul(v,U),S=r.add(S,v),N=r.mul($,A),N=r.add(N,N),v=r.mul(N,U),O=r.sub(O,v),I=r.mul(N,z),I=r.add(I,I),I=r.add(I,I),new l(O,S,I)}add(u){f(u);const{px:b,py:B,pz:w}=this,{px:$,py:A,pz:O}=u;let S=r.ZERO,I=r.ZERO,v=r.ZERO;const z=t.a,N=r.mul(t.b,ar);let U=r.mul(b,$),F=r.mul(B,A),x=r.mul(w,O),y=r.add(b,B),E=r.add($,A);y=r.mul(y,E),E=r.add(U,F),y=r.sub(y,E),E=r.add(b,w);let C=r.add($,O);return E=r.mul(E,C),C=r.add(U,x),E=r.sub(E,C),C=r.add(B,w),S=r.add(A,O),C=r.mul(C,S),S=r.add(F,x),C=r.sub(C,S),v=r.mul(z,E),S=r.mul(N,x),v=r.add(S,v),S=r.sub(F,v),v=r.add(F,v),I=r.mul(S,v),F=r.add(U,U),F=r.add(F,U),x=r.mul(z,x),E=r.mul(N,E),F=r.add(F,x),x=r.sub(U,x),x=r.mul(z,x),E=r.add(E,x),U=r.mul(F,E),I=r.add(I,U),U=r.mul(C,E),S=r.mul(y,S),S=r.sub(S,U),U=r.mul(y,F),v=r.mul(C,v),v=r.add(v,U),new l(S,I,v)}subtract(u){return this.add(u.negate())}is0(){return this.equals(l.ZERO)}wNAF(u){return m.wNAFCached(this,u,l.normalizeZ)}multiplyUnsafe(u){const{endo:b,n:B}=t;xe("scalar",u,ie,B);const w=l.ZERO;if(u===ie)return w;if(this.is0()||u===K)return this;if(!b||m.hasPrecomputes(this))return m.wNAFCachedUnsafe(this,u,l.normalizeZ);let{k1neg:$,k1:A,k2neg:O,k2:S}=b.splitScalar(u),I=w,v=w,z=this;for(;A>ie||S>ie;)A&K&&(I=I.add(z)),S&K&&(v=v.add(z)),z=z.double(),A>>=K,S>>=K;return $&&(I=I.negate()),O&&(v=v.negate()),v=new l(r.mul(v.px,b.beta),v.py,v.pz),I.add(v)}multiply(u){const{endo:b,n:B}=t;xe("scalar",u,K,B);let w,$;if(b){const{k1neg:A,k1:O,k2neg:S,k2:I}=b.splitScalar(u);let{p:v,f:z}=this.wNAF(O),{p:N,f:U}=this.wNAF(I);v=m.constTimeNegate(A,v),N=m.constTimeNegate(S,N),N=new l(r.mul(N.px,b.beta),N.py,N.pz),w=v.add(N),$=z.add(U)}else{const{p:A,f:O}=this.wNAF(u);w=A,$=O}return l.normalizeZ([w,$])[0]}multiplyAndAddUnsafe(u,b,B){const w=l.BASE,$=(O,S)=>S===ie||S===K||!O.equals(w)?O.multiplyUnsafe(S):O.multiply(S),A=$(this,b).add($(u,B));return A.is0()?void 0:A}toAffine(u){return h(this,u)}isTorsionFree(){const{h:u,isTorsionFree:b}=t;if(u===K)return!0;if(b)return b(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:u,clearCofactor:b}=t;return u===K?this:b?b(l,this):this.multiplyUnsafe(t.h)}toRawBytes(u=!0){return Ue("isCompressed",u),this.assertValidity(),i(l,this,u)}toHex(u=!0){return Ue("isCompressed",u),ke(this.toRawBytes(u))}}l.BASE=new l(t.Gx,t.Gy,r.ONE),l.ZERO=new l(r.ZERO,r.ONE,r.ZERO);const p=t.nBitLength,m=us(l,t.endo?Math.ceil(p/2):p);return{CURVE:t,ProjectivePoint:l,normPrivateKeyToScalar:a,weierstrassEquation:o,isWithinCurveOrder:c}}function ws(e){const t=Qr(e);return Me(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function xs(e){const t=ws(e),{Fp:r,n}=t,i=r.BYTES+1,s=2*r.BYTES+1;function o(x){return M(x,n)}function c(x){return vt(x,n)}const{ProjectivePoint:a,normPrivateKeyToScalar:f,weierstrassEquation:h,isWithinCurveOrder:d}=gs({...t,toBytes(x,y,E){const C=y.toAffine(),k=r.toBytes(C.x),P=Te;return Ue("isCompressed",E),E?P(Uint8Array.from([y.hasEvenY()?2:3]),k):P(Uint8Array.from([4]),k,r.toBytes(C.y))},fromBytes(x){const y=x.length,E=x[0],C=x.subarray(1);if(y===i&&(E===2||E===3)){const k=we(C);if(!it(k,K,r.ORDER))throw new Error("Point is not on curve");const P=h(k);let q;try{q=r.sqrt(P)}catch(Z){const V=Z instanceof Error?": "+Z.message:"";throw new Error("Point is not on curve"+V)}const R=(q&K)===K;return(E&1)===1!==R&&(q=r.neg(q)),{x:k,y:q}}else if(y===s&&E===4){const k=r.fromBytes(C.subarray(0,r.BYTES)),P=r.fromBytes(C.subarray(r.BYTES,2*r.BYTES));return{x:k,y:P}}else{const k=i,P=s;throw new Error("invalid Point, expected length of "+k+", or uncompressed "+P+", got "+y)}}}),l=x=>ke(Ne(x,t.nByteLength));function p(x){const y=n>>K;return x>y}function m(x){return p(x)?o(-x):x}const g=(x,y,E)=>we(x.slice(y,E));class u{constructor(y,E,C){this.r=y,this.s=E,this.recovery=C,this.assertValidity()}static fromCompact(y){const E=t.nByteLength;return y=Y("compactSignature",y,E*2),new u(g(y,0,E),g(y,E,2*E))}static fromDER(y){const{r:E,s:C}=ne.toSig(Y("DER",y));return new u(E,C)}assertValidity(){xe("r",this.r,K,n),xe("s",this.s,K,n)}addRecoveryBit(y){return new u(this.r,this.s,y)}recoverPublicKey(y){const{r:E,s:C,recovery:k}=this,P=O(Y("msgHash",y));if(k==null||![0,1,2,3].includes(k))throw new Error("recovery id invalid");const q=k===2||k===3?E+t.n:E;if(q>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const R=k&1?"03":"02",Q=a.fromHex(R+l(q)),Z=c(q),V=o(-P*Z),Be=o(C*Z),se=a.BASE.multiplyAndAddUnsafe(Q,V,Be);if(!se)throw new Error("point at infinify");return se.assertValidity(),se}hasHighS(){return p(this.s)}normalizeS(){return this.hasHighS()?new u(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return Le(this.toDERHex())}toDERHex(){return ne.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Le(this.toCompactHex())}toCompactHex(){return l(this.r)+l(this.s)}}const b={isValidPrivateKey(x){try{return f(x),!0}catch{return!1}},normPrivateKeyToScalar:f,randomPrivateKey:()=>{const x=Wr(t.n);return cs(t.randomBytes(x),t.n)},precompute(x=8,y=a.BASE){return y._setWindowSize(x),y.multiply(BigInt(3)),y}};function B(x,y=!0){return a.fromPrivateKey(x).toRawBytes(y)}function w(x){const y=ye(x),E=typeof x=="string",C=(y||E)&&x.length;return y?C===i||C===s:E?C===2*i||C===2*s:x instanceof a}function $(x,y,E=!0){if(w(x))throw new Error("first arg must be private key");if(!w(y))throw new Error("second arg must be public key");return a.fromHex(y).multiply(f(x)).toRawBytes(E)}const A=t.bits2int||function(x){if(x.length>8192)throw new Error("input is too large");const y=we(x),E=x.length*8-t.nBitLength;return E>0?y>>BigInt(E):y},O=t.bits2int_modN||function(x){return o(A(x))},S=Tt(t.nBitLength);function I(x){return xe("num < 2^"+t.nBitLength,x,ie,S),Ne(x,t.nByteLength)}function v(x,y,E=z){if(["recovered","canonical"].some(ue=>ue in E))throw new Error("sign() legacy options not supported");const{hash:C,randomBytes:k}=t;let{lowS:P,prehash:q,extraEntropy:R}=E;P==null&&(P=!0),x=Y("msgHash",x),cr(E),q&&(x=Y("prehashed msgHash",C(x)));const Q=O(x),Z=f(y),V=[I(Z),I(Q)];if(R!=null&&R!==!1){const ue=R===!0?k(r.BYTES):R;V.push(Y("extraEntropy",ue))}const Be=Te(...V),se=Q;function st(ue){const ve=A(ue);if(!d(ve))return;const ot=c(ve),ze=a.BASE.multiply(ve).toAffine(),le=o(ze.x);if(le===ie)return;const je=o(ot*o(se+le*Z));if(je===ie)return;let _e=(ze.x===le?0:2)|Number(ze.y&K),Ae=je;return P&&p(je)&&(Ae=m(je),_e^=1),new u(le,Ae,_e)}return{seed:Be,k2sig:st}}const z={lowS:t.lowS,prehash:!1},N={lowS:t.lowS,prehash:!1};function U(x,y,E=z){const{seed:C,k2sig:k}=v(x,y,E),P=t;return zr(P.hash.outputLen,P.nByteLength,P.hmac)(C,k)}a.BASE._setWindowSize(8);function F(x,y,E,C=N){var _e;const k=x;y=Y("msgHash",y),E=Y("publicKey",E);const{lowS:P,prehash:q,format:R}=C;if(cr(C),"strict"in C)throw new Error("options.strict was renamed to lowS");if(R!==void 0&&R!=="compact"&&R!=="der")throw new Error("format must be compact or der");const Q=typeof k=="string"||ye(k),Z=!Q&&!R&&typeof k=="object"&&k!==null&&typeof k.r=="bigint"&&typeof k.s=="bigint";if(!Q&&!Z)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let V,Be;try{if(Z&&(V=new u(k.r,k.s)),Q){try{R!=="compact"&&(V=u.fromDER(k))}catch(Ae){if(!(Ae instanceof ne.Err))throw Ae}!V&&R!=="der"&&(V=u.fromCompact(k))}Be=a.fromHex(E)}catch{return!1}if(!V||P&&V.hasHighS())return!1;q&&(y=t.hash(y));const{r:se,s:st}=V,ue=O(y),ve=c(st),ot=o(ue*ve),ze=o(se*ve),le=(_e=a.BASE.multiplyAndAddUnsafe(Be,ot,ze))==null?void 0:_e.toAffine();return le?o(le.x)===se:!1}return{CURVE:t,getPublicKey:B,getSharedSecret:$,sign:U,verify:F,ProjectivePoint:a,Signature:u,utils:b}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function ys(e){return{hash:e,hmac:(t,...r)=>Fe(e,t,Ke(...r)),randomBytes:mn}}function ms(e,t){const r=n=>xs({...e,...ys(n)});return{...r(t),create:r}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const en=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),fr=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Es=BigInt(1),At=BigInt(2),ur=(e,t)=>(e+t/At)/t;function Bs(e){const t=en,r=BigInt(3),n=BigInt(6),i=BigInt(11),s=BigInt(22),o=BigInt(23),c=BigInt(44),a=BigInt(88),f=e*e*e%t,h=f*f*e%t,d=D(h,r,t)*h%t,l=D(d,r,t)*h%t,p=D(l,At,t)*f%t,m=D(p,i,t)*p%t,g=D(m,s,t)*m%t,u=D(g,c,t)*g%t,b=D(u,a,t)*u%t,B=D(b,c,t)*g%t,w=D(B,r,t)*h%t,$=D(w,o,t)*m%t,A=D($,n,t)*f%t,O=D(A,At,t);if(!St.eql(St.sqr(O),e))throw new Error("Cannot find square root");return O}const St=Zr(en,void 0,void 0,{sqrt:Bs}),W=ms({a:BigInt(0),b:BigInt(7),Fp:St,n:fr,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const t=fr,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Es*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=r,o=BigInt("0x100000000000000000000000000000000"),c=ur(s*e,t),a=ur(-n*e,t);let f=M(e-c*r-a*i,t),h=M(-c*n-a*s,t);const d=f>o,l=h>o;if(d&&(f=t-f),l&&(h=t-h),f>o||h>o)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:d,k1:f,k2neg:l,k2:h}}}},jt);BigInt(0);W.ProjectivePoint;const[vs,As]=H.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(e=>BigInt(e))),ae=new Uint32Array(80),fe=new Uint32Array(80);class Ss extends kt{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:t,Al:r,Bh:n,Bl:i,Ch:s,Cl:o,Dh:c,Dl:a,Eh:f,El:h,Fh:d,Fl:l,Gh:p,Gl:m,Hh:g,Hl:u}=this;return[t,r,n,i,s,o,c,a,f,h,d,l,p,m,g,u]}set(t,r,n,i,s,o,c,a,f,h,d,l,p,m,g,u){this.Ah=t|0,this.Al=r|0,this.Bh=n|0,this.Bl=i|0,this.Ch=s|0,this.Cl=o|0,this.Dh=c|0,this.Dl=a|0,this.Eh=f|0,this.El=h|0,this.Fh=d|0,this.Fl=l|0,this.Gh=p|0,this.Gl=m|0,this.Hh=g|0,this.Hl=u|0}process(t,r){for(let w=0;w<16;w++,r+=4)ae[w]=t.getUint32(r),fe[w]=t.getUint32(r+=4);for(let w=16;w<80;w++){const $=ae[w-15]|0,A=fe[w-15]|0,O=H.rotrSH($,A,1)^H.rotrSH($,A,8)^H.shrSH($,A,7),S=H.rotrSL($,A,1)^H.rotrSL($,A,8)^H.shrSL($,A,7),I=ae[w-2]|0,v=fe[w-2]|0,z=H.rotrSH(I,v,19)^H.rotrBH(I,v,61)^H.shrSH(I,v,6),N=H.rotrSL(I,v,19)^H.rotrBL(I,v,61)^H.shrSL(I,v,6),U=H.add4L(S,N,fe[w-7],fe[w-16]),F=H.add4H(U,O,z,ae[w-7],ae[w-16]);ae[w]=F|0,fe[w]=U|0}let{Ah:n,Al:i,Bh:s,Bl:o,Ch:c,Cl:a,Dh:f,Dl:h,Eh:d,El:l,Fh:p,Fl:m,Gh:g,Gl:u,Hh:b,Hl:B}=this;for(let w=0;w<80;w++){const $=H.rotrSH(d,l,14)^H.rotrSH(d,l,18)^H.rotrBH(d,l,41),A=H.rotrSL(d,l,14)^H.rotrSL(d,l,18)^H.rotrBL(d,l,41),O=d&p^~d&g,S=l&m^~l&u,I=H.add5L(B,A,S,As[w],fe[w]),v=H.add5H(I,b,$,O,vs[w],ae[w]),z=I|0,N=H.rotrSH(n,i,28)^H.rotrBH(n,i,34)^H.rotrBH(n,i,39),U=H.rotrSL(n,i,28)^H.rotrBL(n,i,34)^H.rotrBL(n,i,39),F=n&s^n&c^s&c,x=i&o^i&a^o&a;b=g|0,B=u|0,g=p|0,u=m|0,p=d|0,m=l|0,{h:d,l}=H.add(f|0,h|0,v|0,z|0),f=c|0,h=a|0,c=s|0,a=o|0,s=n|0,o=i|0;const y=H.add3L(z,U,x);n=H.add3H(y,v,N,F),i=y|0}({h:n,l:i}=H.add(this.Ah|0,this.Al|0,n|0,i|0)),{h:s,l:o}=H.add(this.Bh|0,this.Bl|0,s|0,o|0),{h:c,l:a}=H.add(this.Ch|0,this.Cl|0,c|0,a|0),{h:f,l:h}=H.add(this.Dh|0,this.Dl|0,f|0,h|0),{h:d,l}=H.add(this.Eh|0,this.El|0,d|0,l|0),{h:p,l:m}=H.add(this.Fh|0,this.Fl|0,p|0,m|0),{h:g,l:u}=H.add(this.Gh|0,this.Gl|0,g|0,u|0),{h:b,l:B}=H.add(this.Hh|0,this.Hl|0,b|0,B|0),this.set(n,i,s,o,c,a,f,h,d,l,p,m,g,u,b,B)}roundClean(){ae.fill(0),fe.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const It=tt(()=>new Ss);/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function $t(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function tn(e,t){return Array.isArray(t)?t.length===0?!0:e?t.every(r=>typeof r=="string"):t.every(r=>Number.isSafeInteger(r)):!1}function Is(e){if(typeof e!="function")throw new Error("function expected");return!0}function Ot(e,t){if(typeof t!="string")throw new Error(`${e}: string expected`);return!0}function Mt(e){if(!Number.isSafeInteger(e))throw new Error(`invalid integer: ${e}`)}function Ht(e){if(!Array.isArray(e))throw new Error("array expected")}function rn(e,t){if(!tn(!0,t))throw new Error(`${e}: array of strings expected`)}function $s(e,t){if(!tn(!1,t))throw new Error(`${e}: array of numbers expected`)}function nn(...e){const t=s=>s,r=(s,o)=>c=>s(o(c)),n=e.map(s=>s.encode).reduceRight(r,t),i=e.map(s=>s.decode).reduce(r,t);return{encode:n,decode:i}}function Os(e){const t=typeof e=="string"?e.split(""):e,r=t.length;rn("alphabet",t);const n=new Map(t.map((i,s)=>[i,s]));return{encode:i=>(Ht(i),i.map(s=>{if(!Number.isSafeInteger(s)||s<0||s>=r)throw new Error(`alphabet.encode: digit index outside alphabet "${s}". Allowed: ${e}`);return t[s]})),decode:i=>(Ht(i),i.map(s=>{Ot("alphabet.decode",s);const o=n.get(s);if(o===void 0)throw new Error(`Unknown letter: "${s}". Allowed: ${e}`);return o}))}}function Hs(e=""){return Ot("join",e),{encode:t=>(rn("join.decode",t),t.join(e)),decode:t=>(Ot("join.decode",t),t.split(e))}}function lr(e,t,r){if(t<2)throw new Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);if(r<2)throw new Error(`convertRadix: invalid to=${r}, base cannot be less than 2`);if(Ht(e),!e.length)return[];let n=0;const i=[],s=Array.from(e,c=>{if(Mt(c),c<0||c>=t)throw new Error(`invalid integer: ${c}`);return c}),o=s.length;for(;;){let c=0,a=!0;for(let f=n;f<o;f++){const h=s[f],d=t*c,l=d+h;if(!Number.isSafeInteger(l)||d/t!==c||l-h!==d)throw new Error("convertRadix: carry overflow");const p=l/r;c=l%r;const m=Math.floor(p);if(s[f]=m,!Number.isSafeInteger(m)||m*r+c!==l)throw new Error("convertRadix: carry overflow");if(a)m?a=!1:n=f;else continue}if(i.push(c),a)break}for(let c=0;c<e.length-1&&e[c]===0;c++)i.push(0);return i.reverse()}function Cs(e){Mt(e);const t=2**8;return{encode:r=>{if(!$t(r))throw new Error("radix.encode input should be Uint8Array");return lr(Array.from(r),t,e)},decode:r=>($s("radix.decode",r),Uint8Array.from(lr(r,e,t)))}}function Us(e,t){return Mt(e),Is(t),{encode(r){if(!$t(r))throw new Error("checksum.encode: input should be Uint8Array");const n=t(r).slice(0,e),i=new Uint8Array(r.length+e);return i.set(r),i.set(n,r.length),i},decode(r){if(!$t(r))throw new Error("checksum.decode: input should be Uint8Array");const n=r.slice(0,-e),i=r.slice(-e),s=t(n).slice(0,e);for(let o=0;o<e;o++)if(s[o]!==i[o])throw new Error("Invalid checksum");return n}}}const ks=e=>nn(Cs(58),Os(e),Hs("")),Ls=ks("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),Ns=e=>nn(Us(4,t=>e(e(t))),Ls);/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */const We=W.ProjectivePoint,bt=Ns(jt);function dr(e){G(e);const t=e.length===0?"0":wn(e);return BigInt("0x"+t)}function zs(e){if(typeof e!="bigint")throw new Error("bigint expected");return xn(e.toString(16).padStart(64,"0"))}const js=Br("Bitcoin seed"),gt={private:76066276,public:76067358},wt=2147483648,_s=e=>Un(jt(e)),Ps=e=>ge(e).getUint32(0,!1),Xe=e=>{if(!Number.isSafeInteger(e)||e<0||e>2**32-1)throw new Error("invalid number, should be from 0 to 2**32-1, got "+e);const t=new Uint8Array(4);return ge(t).setUint32(0,e,!1),t};class pe{get fingerprint(){if(!this.pubHash)throw new Error("No publicKey set!");return Ps(this.pubHash)}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this.privKeyBytes||null}get publicKey(){return this.pubKey||null}get privateExtendedKey(){const t=this.privateKey;if(!t)throw new Error("No private key");return bt.encode(this.serialize(this.versions.private,Ke(new Uint8Array([0]),t)))}get publicExtendedKey(){if(!this.pubKey)throw new Error("No public key");return bt.encode(this.serialize(this.versions.public,this.pubKey))}static fromMasterSeed(t,r=gt){if(G(t),8*t.length<128||8*t.length>512)throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got "+t.length);const n=Fe(It,js,t);return new pe({versions:r,chainCode:n.slice(32),privateKey:n.slice(0,32)})}static fromExtendedKey(t,r=gt){const n=bt.decode(t),i=ge(n),s=i.getUint32(0,!1),o={versions:r,depth:n[4],parentFingerprint:i.getUint32(5,!1),index:i.getUint32(9,!1),chainCode:n.slice(13,45)},c=n.slice(45),a=c[0]===0;if(s!==r[a?"private":"public"])throw new Error("Version mismatch");return a?new pe({...o,privateKey:c.slice(1)}):new pe({...o,publicKey:c})}static fromJSON(t){return pe.fromExtendedKey(t.xpriv)}constructor(t){if(this.depth=0,this.index=0,this.chainCode=null,this.parentFingerprint=0,!t||typeof t!="object")throw new Error("HDKey.constructor must not be called directly");if(this.versions=t.versions||gt,this.depth=t.depth||0,this.chainCode=t.chainCode||null,this.index=t.index||0,this.parentFingerprint=t.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");if(t.publicKey&&t.privateKey)throw new Error("HDKey: publicKey and privateKey at same time.");if(t.privateKey){if(!W.utils.isValidPrivateKey(t.privateKey))throw new Error("Invalid private key");this.privKey=typeof t.privateKey=="bigint"?t.privateKey:dr(t.privateKey),this.privKeyBytes=zs(this.privKey),this.pubKey=W.getPublicKey(t.privateKey,!0)}else if(t.publicKey)this.pubKey=We.fromHex(t.publicKey).toRawBytes(!0);else throw new Error("HDKey: no public or private key provided");this.pubHash=_s(this.pubKey)}derive(t){if(!/^[mM]'?/.test(t))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(t))return this;const r=t.replace(/^[mM]'?\//,"").split("/");let n=this;for(const i of r){const s=/^(\d+)('?)$/.exec(i),o=s&&s[1];if(!s||s.length!==3||typeof o!="string")throw new Error("invalid child index: "+i);let c=+o;if(!Number.isSafeInteger(c)||c>=wt)throw new Error("Invalid index");s[2]==="'"&&(c+=wt),n=n.deriveChild(c)}return n}deriveChild(t){if(!this.pubKey||!this.chainCode)throw new Error("No publicKey or chainCode set");let r=Xe(t);if(t>=wt){const c=this.privateKey;if(!c)throw new Error("Could not derive hardened child key");r=Ke(new Uint8Array([0]),c,r)}else r=Ke(this.pubKey,r);const n=Fe(It,this.chainCode,r),i=dr(n.slice(0,32)),s=n.slice(32);if(!W.utils.isValidPrivateKey(i))throw new Error("Tweak bigger than curve order");const o={versions:this.versions,chainCode:s,depth:this.depth+1,parentFingerprint:this.fingerprint,index:t};try{if(this.privateKey){const c=M(this.privKey+i,W.CURVE.n);if(!W.utils.isValidPrivateKey(c))throw new Error("The tweak was out of range or the resulted private key is invalid");o.privateKey=c}else{const c=We.fromHex(this.pubKey).add(We.fromPrivateKey(i));if(c.equals(We.ZERO))throw new Error("The tweak was equal to negative P, which made the result key invalid");o.publicKey=c.toRawBytes(!0)}return new pe(o)}catch{return this.deriveChild(t+1)}}sign(t){if(!this.privateKey)throw new Error("No privateKey set!");return G(t,32),W.sign(t,this.privKey).toCompactRawBytes()}verify(t,r){if(G(t,32),G(r,64),!this.publicKey)throw new Error("No publicKey set!");let n;try{n=W.Signature.fromCompact(r)}catch{return!1}return W.verify(n,t,this.publicKey)}wipePrivateData(){return this.privKey=void 0,this.privKeyBytes&&(this.privKeyBytes.fill(0),this.privKeyBytes=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(t,r){if(!this.chainCode)throw new Error("No chainCode set");return G(r,33),Ke(Xe(t),new Uint8Array([this.depth]),Xe(this.parentFingerprint),Xe(this.index),this.chainCode,r)}}function Ks(e){const{privateKey:t}=e,r=W.ProjectivePoint.fromPrivateKey(Pr(t).slice(2));return Fi(r)}function sn(e){return{derive:t=>sn(e.derive(t)),depth:e.depth,identifier:me(e.identifier),index:e.index,privateKey:me(e.privateKey),privateExtendedKey:e.privateExtendedKey,publicKey:Ks({privateKey:e.privateKey}),publicExtendedKey:e.publicExtendedKey,versions:e.versions}}function Ts(e,t={}){const{versions:r}=t,n=pe.fromMasterSeed(Fr(e),r);return sn(n)}function Fs(e={}){const{account:t=0,change:r=0,index:n=0}=e;return`m/44'/60'/${t}'/${r}/${n}`}function Rs(e,t,r,n){mr(e);const i=yn({dkLen:32,asyncTick:10},n),{c:s,dkLen:o,asyncTick:c}=i;if(be(s),be(o),be(c),s<1)throw new Error("PBKDF2: iterations (c) should be >= 1");const a=Ce(t),f=Ce(r),h=new Uint8Array(o),d=Fe.create(e,a),l=d._cloneInto().update(f);return{c:s,dkLen:o,asyncTick:c,DK:h,PRF:d,PRFSalt:l}}function Ms(e,t,r,n,i){return e.destroy(),t.destroy(),n&&n.destroy(),i.fill(0),r}function qs(e,t,r,n){const{c:i,dkLen:s,DK:o,PRF:c,PRFSalt:a}=Rs(e,t,r,n);let f;const h=new Uint8Array(4),d=ge(h),l=new Uint8Array(c.outputLen);for(let p=1,m=0;m<s;p++,m+=c.outputLen){const g=o.subarray(m,m+c.outputLen);d.setInt32(0,p,!1),(f=a._cloneInto(f)).update(h).digestInto(l),g.set(l.subarray(0,g.length));for(let u=1;u<i;u++){c._cloneInto(f).update(l).digestInto(l);for(let b=0;b<g.length;b++)g[b]^=l[b]}}return Ms(c,a,o,f,l)}/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */function on(e){if(typeof e!="string")throw new TypeError("invalid mnemonic type: "+typeof e);return e.normalize("NFKD")}function Vs(e){const t=on(e),r=t.split(" ");if(![12,15,18,21,24].includes(r.length))throw new Error("Invalid mnemonic");return{nfkd:t,words:r}}const Ds=e=>on("mnemonic"+e);function Gs(e,t=""){return qs(It,Vs(e).nfkd,Ds(t),{c:2048,dkLen:64})}function Zs(e,t={}){const{passphrase:r}=t,n=Ys(e,{passphrase:r});return Ts(n)}function Ys(e,t={}){const{passphrase:r}=t,n=Gs(e,r);return t.as==="Hex"?zi(n):n}const Ct=1e3,Oe=64,xt=Oe/2,J="gradient-avatar-",Ws=fn(["shrink-0 rounded-full overflow-hidden"],{variants:{size:{xs:"w-3 h-3",sm:"w-5 h-5",md:"w-8 h-8",lg:"w-10 h-10",xl:"w-[52px] h-[52px]"}},defaultVariants:{size:"md"}}),yt=(e,t=Ct)=>e%t/(Ct/Oe),Ie=(e,t=0)=>{let r=3735928559^t,n=1103547991^t;for(let i=0,s;i<e.length;i++)s=e.charCodeAt(i),r=Math.imul(r^s,2654435761),n=Math.imul(n^s,1597334677);return r=Math.imul(r^r>>>16,2246822507)^Math.imul(n^n>>>13,3266489909),n=Math.imul(n^n>>>16,2246822507)^Math.imul(r^r>>>13,3266489909),4294967296*(2097151&n)+(r>>>0)},Xs=(e,t,r)=>{const n=e%360,i=(e+120)%360,s=r%360;return{a:`hsl(${n}deg 100% 40%)`,b:`hsl(${i}deg 100% 50%)`,c:`hsl(${s}deg 100% 50%)`}},Js=(e,t)=>{const r=[];for(let n=0;n<t;n++){const i=n*6;r.push({a:Ie(e+"a",i),b:Ie(e+"b",i+1),c:Ie(e+"c",i+2),x:Ie(e+"d",i+3),y:Ie(e+"e",i+4),r:Ie(e+"f",i+5)})}return r.map((n,i)=>{const s=Oe/10+yt(n.r,Ct*1.5/(i+1));return{...Xs(n.a,n.b,n.c),x:yt(n.x),y:yt(n.y),r:s}})},et=qe.memo(e=>{const{className:t,address:r,size:n="md",complexity:i=1,...s}=e,o=Js(r,i),c=qe.useId();return L.jsxs("svg",{className:un(Ws({size:n}),t),viewBox:`0 0 ${Oe} ${Oe}`,version:"1.1",xmlns:"http://www.w3.org/2000/svg",...s,children:[L.jsxs("defs",{children:[L.jsx("clipPath",{id:`${J}circle-clip${c}`,children:L.jsx("circle",{cx:xt,cy:xt,r:xt})}),L.jsxs("filter",{id:`${J}blur-xs${c}`,x:"-10%",y:"-10%",width:"120%",height:"120%",filterUnits:"userSpaceOnUse",colorInterpolationFilters:"sRGB",children:[L.jsx("feFlood",{floodOpacity:"0",result:"BackgroundImageFix"}),L.jsx("feBlend",{mode:"normal",in:"SourceGraphic",in2:"BackgroundImageFix",result:"shape"}),L.jsx("feGaussianBlur",{stdDeviation:Oe/10,result:"effect1_foregroundBlur"})]}),L.jsxs("linearGradient",{id:`${J}background${c}`,x1:"0",y1:"0",x2:"1",y2:"1",children:[L.jsx("stop",{offset:"0",stopColor:o[0].c}),L.jsx("stop",{offset:"1",stopColor:o[0].a})]}),o.map((a,f)=>L.jsxs(qe.Fragment,{children:[L.jsxs("radialGradient",{id:`${J}primary${c}${f}`,children:[L.jsx("stop",{offset:"0",stopColor:a.a}),L.jsx("stop",{offset:"1",stopColor:a.b})]}),L.jsxs("radialGradient",{id:`${J}secondary${c}${f}`,children:[L.jsx("stop",{offset:"0",stopColor:a.c}),L.jsx("stop",{offset:"1",stopColor:a.b})]})]},f))]}),L.jsxs("g",{clipPath:`url(#${J}circle-clip${c})`,children:[L.jsx("rect",{width:"100%",height:"100%",fill:`url(#${J}background${c})`}),L.jsx("g",{filter:`url(#${J}blur-xs${c})`,children:o.map((a,f)=>L.jsxs(qe.Fragment,{children:[L.jsx("circle",{fill:`url(#${J}primary${c}${f})`,cx:a.x,cy:a.y,r:a.r}),L.jsx("circle",{fill:`url(#${J}secondary${c}${f})`,cx:a.y,cy:a.x,r:a.r/2})]},f))})]})]})});try{et.displayName="GradientAvatar",et.__docgenInfo={description:"",displayName:"GradientAvatar",props:{address:{defaultValue:null,description:"",name:"address",required:!0,type:{name:"string"}},initials:{defaultValue:null,description:"",name:"initials",required:!1,type:{name:"string"}},complexity:{defaultValue:null,description:"",name:"complexity",required:!1,type:{name:"number"}},className:{defaultValue:null,description:"",name:"className",required:!1,type:{name:"string"}},size:{defaultValue:null,description:"",name:"size",required:!1,type:{name:'"sm" | "md" | "lg" | "xs" | "xl" | null'}}}}}catch{}const Qs="bulb cute board file buddy subway memory exercise busy repair foam item",po={title:"Components/GradientAvatar",component:et},Je={args:{address:"0x1234567890123456789012345678901234567890"}},eo=3,to=8,cn=[["0x8e3E38fe7367dd3b52D1e281E4e8400447C8d8B9","0x73F8E47dEe63002378E047fA74e6DFb24F88f496","0x9Cb019C2FfcD9E9BB83e269625a170179Ff3ECD0","0x9b436D9599FAc498e1e0Ab4D48cDFC72922a6F1e","0x9aB58Bda3eeCbF391a17592ed7626727b922a18f","0x468E8e29F6cfb0F6b7ff10ec6A1AB516ec849c04","0x450cB9fbB2D44d166AACA1f6cDb1dBd9Ff168e4C","0x88cc3E896C4C178AB98333dCD29C33d2cc2102A8"],["0x8e3E38fe7367dd3b52D1e281E4e8400447C8d8Bx","0x73F8E47dEe63002378E047fA74e6DFb24F88f49x","0x9Cb019C2FfcD9E9BB83e269625a170179Ff3ECDx","0x9b436D9599FAc498e1e0Ab4D48cDFC72922a6F1x","0x9aB58Bda3eeCbF391a17592ed7626727b922a18x","0x468E8e29F6cfb0F6b7ff10ec6A1AB516ec849c0x","0x450cB9fbB2D44d166AACA1f6cDb1dBd9Ff168e4x","0x88cc3E896C4C178AB98333dCD29C33d2cc2102Ax"]],ro=(e,t,r)=>{const{publicKey:n}=Zs(e).derive(Fs({account:t,change:r})),i=Wi(n);return Rt(i)};for(let e=0;e<eo;e++){const t=[];for(let r=0;r<to;r++)t.push(ro(Qs,e,r));cn.push(t)}const Qe=()=>L.jsxs(L.Fragment,{children:[L.jsx(an,{variant:"normal",color:"primary",fontWeight:"bold",asChild:!0,children:L.jsx("div",{children:"SVG"})}),L.jsx("div",{className:"flex flex-col gap-4",children:cn.map((e,t)=>L.jsx("div",{className:"flex gap-4",children:e.map(r=>L.jsx(et,{address:r,size:"xl"},r))},t))})]});var hr,pr,br;Je.parameters={...Je.parameters,docs:{...(hr=Je.parameters)==null?void 0:hr.docs,source:{originalSource:`{
  args: {
    address: '0x1234567890123456789012345678901234567890'
  }
}`,...(br=(pr=Je.parameters)==null?void 0:pr.docs)==null?void 0:br.source}}};var gr,wr,xr;Qe.parameters={...Qe.parameters,docs:{...(gr=Qe.parameters)==null?void 0:gr.docs,source:{originalSource:`() => {
  return <>
      <Text variant="normal" color="primary" fontWeight="bold" asChild>
        <div>SVG</div>
      </Text>

      <div className="flex flex-col gap-4">
        {rows.map((cols, idx) => <div className="flex gap-4" key={idx}>
            {cols.map(address => <GradientAvatar key={address} address={address} size="xl" />)}
          </div>)}
      </div>
    </>;
}`,...(xr=(wr=Qe.parameters)==null?void 0:wr.docs)==null?void 0:xr.source}}};const bo=["Default","Multiple"];export{Je as Default,Qe as Multiple,bo as __namedExportsOrder,po as default};
